{"title":"A5-数据结构","uid":"40f7427d94a97a10aada378041f90424","slug":"A5-数据结构","date":"2022-10-06T04:19:24.384Z","updated":"2022-10-29T08:47:49.915Z","comments":true,"path":"api/articles/A5-数据结构.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210022323780.png","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">为什么选择利用数组模拟数据结构</p>\n<p>-链表需要频繁使用new/malloc动态申请结点空间，会占用大量的时间和空间。</p>\n<p>-利用数组模拟数据结构相当于在内存使用前先申请分配一定大小的空间作为备用，并利用数组下标代替内存地址实现结点的链式储存。</p>\n\n</div>\n<h3 id=\"静态链表\"><a href=\"#静态链表\" class=\"headerlink\" title=\"静态链表\"></a>静态链表</h3><h4 id=\"单链表\"><a href=\"#单链表\" class=\"headerlink\" title=\"单链表\"></a>单链表</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\n// head 表示头结点的下标 ==&gt; 头指针\n// e[i] 表示结点 i 的值 ==&gt; data域\n// ne[i] 表示结点 i 后继结点的下标 ==&gt; 指针域\n// idx 标记在数组内存中当前使用到的位置\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init() {\n\thead = -1;\n    idx = 0;\n}\nvoid push_front(int x) {  // 头插法\n\te[idx] = x;\n    ne[idx] = head;\n    head = idx++;\n}\nvoid pop_front() {\n    head = ne[head];\n}</code></pre>\n\n<h4 id=\"双向链表\"><a href=\"#双向链表\" class=\"headerlink\" title=\"双向链表\"></a>双向链表</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\nint e[N], l[N], r[N], idx;\nvoid init() {\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}</code></pre>\n\n<h3 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int stack[N], top = 0; // 栈底为1\nvoid push(int x) {\n    stack[++ top] = x;\n}\nvoid pop() {\n    if(!StackEmpty()) -- top;\n}\nvoid StackEmpty() {\n    return top == 0;\n}</code></pre>\n\n<h3 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h3><h4 id=\"普通队列\"><a href=\"#普通队列\" class=\"headerlink\" title=\"普通队列\"></a>普通队列</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int queue[N], front = 0, rear = -1; // 队头为1\nvoid push_back(int x) {\n    queue[++ rear] = x;\n}\nvoid pop_front() {\n    if(!QueueEmpty()) ++ front;\n}\nvoid QueueEmpty() {\n\treturn front &gt; rear;\n}</code></pre>\n\n<h4 id=\"循环队列\"><a href=\"#循环队列\" class=\"headerlink\" title=\"循环队列\"></a>循环队列</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int sqQueue[N], front = rear = 0;\nvoid push_back(int x) {\n    queue[rear ++] = x;\n    if(rear == N) rear = 0;\n}\nvoid pop_front() {\n    if(!QueueEmpty()) {\n    \t++ front;\n        if(front == N) front = 0;\n    }\n}\nvoid QueueEmpty() {\n\treturn front == rear;\n}</code></pre>\n\n<h3 id=\"单调栈\"><a href=\"#单调栈\" class=\"headerlink\" title=\"单调栈\"></a>单调栈</h3><p>适用于找出每个数左边离它最近的比它大/小的数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int stack[N], top = 0; // stack 储存下标\nfor (int i = 0; i &lt; N; ++i) {\n    // 小于 i 的所有元素出栈\n\twhile(top &amp;&amp; stack[top] &gt; arr[i]) -- top;\n    stack[++ top] = i;\n}</code></pre>\n\n<h3 id=\"单调队列\"><a href=\"#单调队列\" class=\"headerlink\" title=\"单调队列\"></a>单调队列</h3><p>适用于求滑动窗口中的最大值/最小值。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int queue[N], front = 0, rear = -1;\nfor (int i = 0; i &lt; N; ++i) {\n\twhile(front &lt;= rear &amp;&amp; i - front &gt; k) ++ front; // 超出窗口范围\n    while(front &lt;= reae &amp;&amp; queue[rear] &lt;= arr[i]) -- rear; // 保持队列元素单调递减\n    queue[++ rear] = i;\n}</code></pre>\n\n<h3 id=\"KMP\"><a href=\"#KMP\" class=\"headerlink\" title=\"KMP\"></a>KMP</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010, M = 1000010;\nchar s[M], p[N];\nint ne[N];\n// 字符串s，模式串p，len(s)=n，len(p)=m，数组下标从1开始\nint n, m;\nint main() {\n    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\n    // 求模式串的 Next 数组: 相当于两个模式串间的匹配\n    for (int i = 2, j = 0; i &lt;= n; ++ i) {\n        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n        if(p[i] == p[j + 1]) ++ j;\n        ne[i] = j;\n    }\n    // 匹配: i遍历字符串s, j标记模式串当前匹配到的位置\n    for(int i = 1, j = 0; i &lt;= m; ++ i) {\n        while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // 递归匹配最大前后缀，j = 0 时应退出循环\n        if(s[i] == p[j + 1]) ++ j;\n        if(j == n) {\n            cout &lt;&lt; i - n + 1;\n            j = ne[j]; // 寻找下一匹配项\n        }\n    }\n    return 0;\n}</code></pre>\n\n<h3 id=\"Trie树\"><a href=\"#Trie树\" class=\"headerlink\" title=\"Trie树\"></a>Trie树</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.448ex\" height=\"1.557ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -677 1966 688\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D447\" d=\"M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(704,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1155,0)\"><path data-c=\"1D456\" d=\"M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1500,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g></g></svg></mjx-container>树又称为前缀树，原理是利用字符串的公共前缀提高搜索效率，但由于每个结点仅存储一个字符，是一种利用空间换时间的算法。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">// 开辟N个结点的内存池，每个结点有26个可用子结点，利用idx进行链接\n// cnt[i]统计以第i个结点为末尾的字符串频数\nint node[N][26], cnt[N], idx;\nvoid insert(char *str) {\n\tint p = 0; // 根结点为node[0]\n    for(int i = 0; str[i]; ++ i) { // 字符串数组以'\\0'结尾\n        int u = str[i] - 'a';\n        if(!node[p][u]) node[p][u] = ++ idx;\n        p = node[p][u];\n    }\n    ++ cnt[p];\n}\nint query(char *str) {\n    int p = 0;\n    for(int i = 0; str[i]; ++ i) {\n        int u = str[i] - 'a';\n        if(!node[p][u]) return 0;\n        p = node[p][u];\n    }\n    return cnt[p];\n}</code></pre>\n\n<h3 id=\"并查集\"><a href=\"#并查集\" class=\"headerlink\" title=\"并查集\"></a>并查集</h3><p>主要支持以下两种操作：</p>\n<ul>\n<li>合并两个不相交的集合</li>\n<li>查询两个元素是否在同一集合中</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int f[N]; // 储存结点的父结点\nint init(int n) {\n    for(int i = 0; i &lt; n; ++ i)\n        f[i] = i;\n}\nint find(int x) { // 寻找结点x的根结点\n    return f[x] == x? x: (f[x] = find(f[x])); // 路径压缩，每次查询时将路径中的结点指向根结点\n}\nvoid merge(int i, int j) {\n    f[find(i)] = find(j); // 将结点i的根结点指向结点j\n}\n// 判断结点i和结点j是否在同一集合内\nfind(i) == find(j)</code></pre>\n\n<h3 id=\"堆（优先队列）\"><a href=\"#堆（优先队列）\" class=\"headerlink\" title=\"堆（优先队列）\"></a>堆（优先队列）</h3><p>堆分为最大堆和最小堆；最大堆中父节点的值比每一个子结点都大，最小堆反之；堆总是一棵完全二叉树。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void down(int u) {\n    int t = u;\n    // 结点 u 是父结点，u * 2 和 u * 2 + 1 分别是它的左右孩子，t标记3个结点中的最小值\n    if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    // 将父结点与值最小的结点交换\n    if(t != u) {\n\t\tnode_swap(t, u);\n        down(t); // 递归地让该结点下沉\n    }\n}\nvoid up(int u) {\n    // 当前结点的值大于父结点就up\n    while(u &gt;&gt; 1 &amp;&amp; h[u] &lt; h[u &gt;&gt; 1]) {\n        node_swap(u, u &gt;&gt; 1);\n        u &gt;&gt;= 1;\n    }\n}\nvoid build_heap() {\n    for(int i = n &gt;&gt; 1; i; -- i) down(i);\n}</code></pre>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","feature":true,"text":" 为什么选择利用数组模拟数据结构 -链表需要频繁使用new/malloc动态申请结点空间，会占用大量的时间和空间。 -利用数组模拟数据结构相当于在内存使用前先申请分配一定大小的空间作为备用，并利用数组下标代替内存地址实现结点的链式储存。 静态链表单链表#include&lt;io...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":5,"path":"api/tags/AcWing算法基础课.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">静态链表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8D%95%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">单链表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8\"><span class=\"toc-text\">双向链表</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A0%88\"><span class=\"toc-text\">栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%98%9F%E5%88%97\"><span class=\"toc-text\">队列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97\"><span class=\"toc-text\">普通队列</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97\"><span class=\"toc-text\">循环队列</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E6%A0%88\"><span class=\"toc-text\">单调栈</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97\"><span class=\"toc-text\">单调队列</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#KMP\"><span class=\"toc-text\">KMP</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Trie%E6%A0%91\"><span class=\"toc-text\">Trie树</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E6%9F%A5%E9%9B%86\"><span class=\"toc-text\">并查集</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%A0%86%EF%BC%88%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%89\"><span class=\"toc-text\">堆（优先队列）</span></a></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Python_tricks","uid":"42f387978a941c90eb0f7971a3f9fdef","slug":"Python_tricks","date":"2022-10-06T04:19:43.000Z","updated":"2022-10-29T08:46:56.923Z","comments":true,"path":"api/articles/Python_tricks.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210291552171.jpg","text":"Swaping valuesa, b = 10, 5 a, b = b, a ####Create a single string from all the elements in list a = [\"Python\", \"is\", \"awesome\"] print(\" \".jo...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"语言特性","slug":"语言特性","count":1,"path":"api/categories/语言特性.json"}],"tags":[{"name":"Python","slug":"Python","count":1,"path":"api/tags/Python.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"A4-前缀和&差分","uid":"1021d88cce27c5945c95fc3401510b8b","slug":"A4-前缀和&差分","date":"2022-10-05T05:52:23.000Z","updated":"2022-10-06T04:26:58.233Z","comments":true,"path":"api/articles/A4-前缀和&差分.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210022301239.jpg","text":"前缀和一维前缀和// 为处理边界, a 的下标从 1 开始： a[1...n], 初始化 s[0] = 0 // 1. 额外开一个前缀和数组 s for(int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i]; // 2. 在原数组基础...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":4,"path":"api/categories/算法.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":5,"path":"api/tags/AcWing算法基础课.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true}}