{"title":"算法1-数学基础","uid":"7dc4f02b5b9064910d8a6525e70f6010","slug":"算法1-数学基础","date":"2022-10-01T09:45:17.000Z","updated":"2022-10-02T07:59:45.428Z","comments":true,"path":"api/articles/算法1-数学基础.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021558813.jpg","content":"<h2 id=\"1-负数的补码形式\"><a href=\"#1-负数的补码形式\" class=\"headerlink\" title=\"(1)负数的补码形式\"></a>(1)负数的补码形式</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>计算机中通常用&#x3D;&#x3D;补码&#x3D;&#x3D;进行数值运算（负数用补码表示）。</p></blockquote>\n<ul>\n<li>引入”模”的概念：</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>模是一个计量系统的计数范围。模是一个溢出的量，只能表示模的余数。有模的计量器可化减法为加法。如时钟的模为12，计量范围可看作0-11，那么从10点拨到6点，可倒拨4h或顺拨8h（即+4和-8的效果相同）。</p></blockquote>\n<ul>\n<li><p>进制运算有模的原理是&#x3D;&#x3D;高位丢失&#x3D;&#x3D;；</p>\n<p>如四位二进制1111加1后为10000，最高位溢出后为0000；不难得到它的模为2^4。</p>\n<p>那么$0100-0010&#x3D;0100+(2^4-0010)&#x3D;0100+(1111-0010)+1$</p>\n<p>由上可知，负数求补码的过程是 &#x3D;&#x3D;取绝对值-&gt;逐位取反-&gt;加1&#x3D;&#x3D;。相同的，由补码转换为原码的方式为 -1-&gt;逐位取反-&gt;加负号。</p>\n</li>\n</ul>\n<h2 id=\"2-大数运算（高精度算法）\"><a href=\"#2-大数运算（高精度算法）\" class=\"headerlink\" title=\"(2)大数运算（高精度算法）\"></a>(2)大数运算（高精度算法）</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>大数指超过计算机表示范围的数值。通常用&#x3D;&#x3D;数组&#x3D;&#x3D;进行表示。</p></blockquote>\n<h3 id=\"高精加低精\"><a href=\"#高精加低精\" class=\"headerlink\" title=\"高精加低精\"></a>高精加低精</h3><p><strong><u>Leetcode 989 数组形式的整数加法</u></strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X &#x3D; 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：A &#x3D; [1,2,0,0], K &#x3D; 34\n输出：[1,2,3,4]\n解释：1200 + 34 &#x3D; 1234</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123;\n    vector&lt;int&gt; ans;\n    int n &#x3D; num.size();\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0 || k &gt; 0; --i, k &#x2F;&#x3D; 10) &#123;\n        if (i &gt;&#x3D; 0) &#123;\n            k +&#x3D; num[i];&#x2F;&#x2F;将k与num最后一位相加，依次向前进位\n        &#125;\n        ans.push_back(k % 10);\n    &#125;\n    reverse(ans.begin(), ans.end());&#x2F;&#x2F;逆序\n    return ans;\n&#125;</code></pre>\n\n<h3 id=\"压位高精\"><a href=\"#压位高精\" class=\"headerlink\" title=\"压位高精\"></a>压位高精</h3><ul>\n<li>普通的高精度算法使用一个数组或字符串元素存储一个十进制数位。为了节省时间和空间，我们使用位压**&#x3D;&#x3D;在每一个int类型的数组中存储4位数字&#x3D;&#x3D;**（5位在乘法中可能会溢出）。</li>\n</ul>\n<hr>\n<h2 id=\"3-判断素数\"><a href=\"#3-判断素数\" class=\"headerlink\" title=\"(3)判断素数\"></a>(3)判断素数</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int isprime(int n)&#123;\n    if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#x2F;&#x2F;0和1不是素数，需要分类讨论\n        return 0;\n    for(int i &#x3D; 2; i &lt;&#x3D; sqrt(n); ++i)\n        if(n % i &#x3D;&#x3D; 0)\n            return 0;\n    return 1;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"4-最大公约数与最小公倍数\"><a href=\"#4-最大公约数与最小公倍数\" class=\"headerlink\" title=\"(4)最大公约数与最小公倍数\"></a>(4)最大公约数与最小公倍数</h2><ul>\n<li><h4 id=\"辗转相除求最大公约数\"><a href=\"#辗转相除求最大公约数\" class=\"headerlink\" title=\"辗转相除求最大公约数\"></a>辗转相除求最大公约数</h4></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。计算公式 $gcd(a,b) &#x3D; gcd(b,a\\ mod\\ b)$，即<strong>两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。</strong></p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;循环形式\nint Gcd(int a, int b)&#123;\n    while(r &gt; 0)&#123;\n        r &#x3D; a % b;\n        a &#x3D; b;\n        b &#x3D; r;\n    &#125;\n    return a;\n&#125;\n&#x2F;&#x2F;递归形式\nint Gcd(int a, int b)&#123;\n    return b &#x3D;&#x3D; 0 ? a : gcd(b, a % b);\n&#125;</code></pre>\n\n<ul>\n<li><h4 id=\"分解质因数求最小公倍数\"><a href=\"#分解质因数求最小公倍数\" class=\"headerlink\" title=\"分解质因数求最小公倍数\"></a>分解质因数求最小公倍数</h4><img src=\"https://s2.loli.net/2022/03/07/nfY3QICb9NADoxt.png\" style=\"zoom: 50%;\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; x * y &#x3D; lcm * gcd\nint Lcm(int x, int y)&#123;\n    int g &#x3D; Gcd(x, y);\n    return fabs(x &#x2F; g * y);   &#x2F;&#x2F; 先乘再除中间量可能会溢出\n&#125;</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"5-负进制转换\"><a href=\"#5-负进制转换\" class=\"headerlink\" title=\"(5)负进制转换\"></a>(5)负进制转换</h2><ul>\n<li><h4 id=\"负数的除法和取余运算：\"><a href=\"#负数的除法和取余运算：\" class=\"headerlink\" title=\"负数的除法和取余运算：\"></a>负数的除法和取余运算：</h4><p>1.正数和负数的除法运算（&#x2F;）都是向0取整的，int类型的除法是直接去掉小数部分；</p>\n<p>2.负数取余先通过取模（绝对值）计算，符号由&#x3D;&#x3D;被除数&#x3D;&#x3D;决定。</p>\n</li>\n</ul>\n<p><strong><u>洛谷 P1017 [NOIP2000 提高组] 进制转换</u></strong></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>设计一个程序,读入一个十进制数<strong>x</strong>和一个负进制数<strong>n</strong>的基数, 并将此十进制数转换为此负进制下的数。</p></blockquote>\n<ul>\n<li><p>如果是以 R 或 -R 为基数,则需要用到的数码为 0,1,……,R−1。</p>\n<p>例如当 R&#x3D;-7 时,所需用到的数码是 0,1,2,3,4,5,6；这与其是 R 或 -R 无关。</p>\n</li>\n<li><p>负进制与正进制大体相同，只不过有时取余的结果会是负数，那么就需要像借位一样，向前借-1，<u>余数就可以转化为正数</u>（因为进制数一定大于余数）。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void NegativeBase(int x, int n)&#123;\n    if(x &#x3D;&#x3D; 0) return;    &#x2F;&#x2F;递归结束条件\n    int remainder;\n    remainder &#x3D; x % n;\n    if (remainder &gt;&#x3D; 0)\n    \tx &#x2F;&#x3D; n;\n    else&#123;\n    \tremainder -&#x3D; n;\n    \tx &#x3D; x &#x2F; n + 1;\n\t&#125;\n    &#x2F;&#x2F;由于输出的是字符类型，需要将remainder转化为相应的ascii值\n    remainder &#x3D; remainder &gt;&#x3D; 10? (remainder-10) + &#39;A&#39;: remainder + &#39;0&#39;;\n    NegativeBase(x, n);\n    &#x2F;&#x2F;函数的递归调用在栈中实现，利用栈的后进先出特点，进行逆序输出，因此输出语句写在递归的后面。\n    printf(&quot;%c&quot;,remainder);\n    return;\n&#125;</code></pre>\n\n<hr>\n<h2 id=\"6-模运算\"><a href=\"#6-模运算\" class=\"headerlink\" title=\"(6)模运算\"></a>(6)模运算</h2><p>取模运算的性质：</p>\n<ol>\n<li>加减乘都适用：(a + b) % p &#x3D; (a % p + b % p) % p</li>\n<li>多次取模等价于一次取模：(a % c) %c &#x3D; a % c</li>\n</ol>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>如果环的模为 m 且元素从 0 开始，那么从 x 开始循环右移 k 位的表达式为 $(x+k)\\ mod\\ m$；如果元素从 1 开始则为$(x-1+k)\\mod\\ m+1$ 。大写字母构成的环可表达为$(x-‘A’+k) \\ mod \\ 26 + 65$ ，其中 x-‘A’ 可以将环构造成元素从 0 开始的环。</p></blockquote>\n<hr>\n<h2 id=\"7-约瑟夫环\"><a href=\"#7-约瑟夫环\" class=\"headerlink\" title=\"(7)约瑟夫环\"></a>(7)约瑟夫环</h2><p><u><strong>Leetcode 剑指 Offer 62. 圆圈中最后剩下的数字</strong></u></p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。</p></blockquote>\n<p>返回的答案应该是&#x3D;&#x3D;剩下的数字在原序列的下标&#x3D;&#x3D;，而问题的关键在于找到&#x3D;&#x3D;每次删除后形成的新序列索引与原序列下标之间的数学关系。&#x3D;&#x3D;</p>\n<img src=\"https://s2.loli.net/2022/03/07/XQCcu4fYElo9vIw.png\" style=\"zoom:67%;\" />\n\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;递归\nint f(int n, int m) &#123;\n    if (n &#x3D;&#x3D; 1) &#123;\n        return 0;\n    &#125;\n    int x &#x3D; f(n - 1, m);\n    return (m + x) % n;\n&#125;\nint lastRemaining(int n, int m) &#123;\n    return f(n, m);\n&#125;\n\n&#x2F;&#x2F;迭代\nint lastRemaining(int n, int m) &#123;\n    int f &#x3D; 0;\n    for (int i &#x3D; 2; i !&#x3D; n + 1; ++i) &#123;\n        f &#x3D; (m + f) % i; \n    &#125;\n    return f;\n&#125;</code></pre>\n\n<h2 id=\"8-快速幂\"><a href=\"#8-快速幂\" class=\"headerlink\" title=\"(8)快速幂\"></a>(8)快速幂</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。</p></blockquote>\n<ul>\n<li><h4 id=\"快速幂的递归方程\"><a href=\"#快速幂的递归方程\" class=\"headerlink\" title=\"快速幂的递归方程\"></a>快速幂的递归方程</h4></li>\n</ul>\n<img src=\"https://s2.loli.net/2022/03/07/msKlQwqphz1ZGN4.png\" style=\"zoom:67%;\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">long long binpow(long long a, long long b) &#123;\n    if (b &#x3D;&#x3D; 0) return 1;\n    long long res &#x3D; binpow(a, b &#x2F; 2); \n    if (b % 2)\n        return res * res * a;  &#x2F;&#x2F; 相当于 binpow(a, n-1) * a\n    else\n        return res * res;\n&#125;</code></pre>\n\n<ul>\n<li><h4 id=\"采用二进制取幂的方法\"><a href=\"#采用二进制取幂的方法\" class=\"headerlink\" title=\"采用二进制取幂的方法\"></a>采用二进制取幂的方法</h4></li>\n</ul>\n<p>通过连续的自乘运算，求出a的$2^k$次幂的序列，将对应二进制位为 1 的整系数幂相乘。</p>\n<p>如$3^{13} &#x3D; 3^{(1101)_2} &#x3D; 3^8 \\cdot 3^4 \\cdot 3^1$</p>\n<img src=\"https://s2.loli.net/2022/03/07/xRsv2Sr7FQJLAni.png\" style=\"zoom: 67%;\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">long long binpow(long long a, long long b) &#123;\n    long long res &#x3D; 1;\n    while (b &gt; 0) &#123;\n        if (b &amp; 1) res &#x3D; res * a;\n        a &#x3D; a * a;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;</code></pre>\n\n<ul>\n<li><h4 id=\"模意义下取幂\"><a href=\"#模意义下取幂\" class=\"headerlink\" title=\"模意义下取幂\"></a>模意义下取幂</h4></li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>计算$a^b\\ mod\\ m$。</p></blockquote>\n<p>模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">long long binpow(long long a, long long b, long long m) &#123;\n  a %&#x3D; m;\n  long long res &#x3D; 1;\n  while (b &gt; 0) &#123;\n    if (b &amp; 1) res &#x3D; res * a % m;\n    a &#x3D; a * a % m;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;</code></pre>\n\n","feature":true,"text":"(1)负数的补码形式 计算机中通常用&#x3D;&#x3D;补码&#x3D;&#x3D;进行数值运算（负数用补码表示）。 引入”模”的概念： 模是一个计量系统的计数范围。模是一个溢出的量，只能表示模的余数。有模的计量器可化减法为加法。如时钟的模为12，计量范围可看作0-11，那么...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"数学基础","slug":"数学基础","count":1,"path":"api/tags/数学基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E8%B4%9F%E6%95%B0%E7%9A%84%E8%A1%A5%E7%A0%81%E5%BD%A2%E5%BC%8F\"><span class=\"toc-text\">(1)负数的补码形式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%A4%A7%E6%95%B0%E8%BF%90%E7%AE%97%EF%BC%88%E9%AB%98%E7%B2%BE%E5%BA%A6%E7%AE%97%E6%B3%95%EF%BC%89\"><span class=\"toc-text\">(2)大数运算（高精度算法）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%AB%98%E7%B2%BE%E5%8A%A0%E4%BD%8E%E7%B2%BE\"><span class=\"toc-text\">高精加低精</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8E%8B%E4%BD%8D%E9%AB%98%E7%B2%BE\"><span class=\"toc-text\">压位高精</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%A4%E6%96%AD%E7%B4%A0%E6%95%B0\"><span class=\"toc-text\">(3)判断素数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0\"><span class=\"toc-text\">(4)最大公约数与最小公倍数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%BE%97%E8%BD%AC%E7%9B%B8%E9%99%A4%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0\"><span class=\"toc-text\">辗转相除求最大公约数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0%E6%B1%82%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0\"><span class=\"toc-text\">分解质因数求最小公倍数</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E8%B4%9F%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">(5)负进制转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B4%9F%E6%95%B0%E7%9A%84%E9%99%A4%E6%B3%95%E5%92%8C%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%EF%BC%9A\"><span class=\"toc-text\">负数的除法和取余运算：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E6%A8%A1%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">(6)模运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#7-%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF\"><span class=\"toc-text\">(7)约瑟夫环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#8-%E5%BF%AB%E9%80%9F%E5%B9%82\"><span class=\"toc-text\">(8)快速幂</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E5%B9%82%E7%9A%84%E9%80%92%E5%BD%92%E6%96%B9%E7%A8%8B\"><span class=\"toc-text\">快速幂的递归方程</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%87%87%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8F%96%E5%B9%82%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">采用二进制取幂的方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%84%8F%E4%B9%89%E4%B8%8B%E5%8F%96%E5%B9%82\"><span class=\"toc-text\">模意义下取幂</span></a></li></ol></li></ol></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"算法2-位运算","uid":"23b460b1d81bc84883e4eda5dcad0a53","slug":"算法2-位运算","date":"2022-10-01T09:46:09.000Z","updated":"2022-10-02T08:00:27.759Z","comments":true,"path":"api/articles/算法2-位运算.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600098.jpg","text":"(1)异或(^)Leetcode 17.04 消失的数 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？ **1.**异或运算的特性：计算机中两个数（补码）按位进行异或； ​ 两个相同的数异或等于0； ​ 任何数与...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true},"next_post":{}}