{"title":"A1-快速&归并排序","uid":"95cb927361df204c35cf3acbf99ad432","slug":"A1-排序","date":"2022-10-01T09:45:17.000Z","updated":"2022-10-03T15:40:11.689Z","comments":true,"path":"api/articles/A1-排序.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021558813.jpg","content":"<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>1.确定pivot(基准值)，一般选择区间右端点；</p>\n<p>2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot；</p>\n<p>3.利用递归实现区间排序。</p></blockquote>\n<h4 id=\"利用双指针法实现区间划分\"><a href=\"#利用双指针法实现区间划分\" class=\"headerlink\" title=\"利用双指针法实现区间划分\"></a>利用双指针法实现区间划分</h4><p>​       左指针从左到右找到第一个不小于基准值的元素，右指针从右到左找到第一个不大于基准值的元素，如果左指针小于右指针，则交换两个指针对应的元素，直到左指针大于等于右指针时停止迭代。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1e6 + 10;\nint n;\nint q[N];\nvoid quick_sort(int q[], int l, int r) &#123;\n    if(l &gt;&#x3D; r) return;\n    int pivot &#x3D; q[l], i &#x3D; l - 1, j &#x3D; r + 1;\n    while(i &lt; j) &#123;\n        &#x2F;&#x2F; 找到第一个不小于基准值的元素\n        do ++i; while(q[i] &lt; pivot);\n        &#x2F;&#x2F; 找到第一个不大于基准值的元素\n        do --j; while(q[j] &gt; pivot);\n        if(i &lt; j) swap(q[i], q[j]);\n    &#125;\n    &#x2F;&#x2F; j指向第一个区间的最后一个元素\n    &#x2F;&#x2F; warning: 使用j进行划分时,base不能取到区间右端点,算例[1, 2]会陷入死循环\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for(int i &#x3D; 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;q[i]);\n    quick_sort(q, 0, n - 1);\n    for(int i &#x3D; 0; i &lt; n; ++i) printf(&quot;%d&quot;, q[i]);\n    return 0;\n&#125;</code></pre>\n\n<h4 id=\"考虑数据不确定性的算法优化\"><a href=\"#考虑数据不确定性的算法优化\" class=\"headerlink\" title=\"考虑数据不确定性的算法优化\"></a>考虑数据不确定性的算法优化</h4><p>​\t\t首先对快速排序的时间复杂度进行分析：</p>\n<ul>\n<li><p>最好情况</p>\n<p>​       每次选取的pivot都能将数组平均地划分为两部分，由于划分的过程为O(n)，所以总的运行时间为O(nlogn)。      </p>\n</li>\n<li><p>最坏情况</p>\n<p>​       假设始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分只能将问题规模减少１，所以运行时间为O(n^2)。</p>\n</li>\n</ul>\n<p>​       排序算法对数据的有序性敏感，且对于大量重复数据，其时间复杂度也可能会退化为O(n^2)，典型如<a href=\"https://leetcode.cn/problems/sort-an-array/\">LeetCode 912 排序数组</a>，存在5w个2的算例，利用朴素的快排会TLE。</p>\n<p>​\t   快排的优化主要在于对pivot的选取，对于Choose-Left和Choose-Right，常见的改进方法有Random和Median-Of-Three：</p>\n<h5 id=\"Random\"><a href=\"#Random\" class=\"headerlink\" title=\"Random\"></a>Random</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">pivot &#x3D; rand() % (l - r) + l</code></pre>\n\n<h5 id=\"Median-Of-Three\"><a href=\"#Median-Of-Three\" class=\"headerlink\" title=\"Median-Of-Three\"></a>Median-Of-Three</h5><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void swap_arr_elm(int q[], int elm1, int elm2) &#123;\n    swap(q[elm1], q[elm2]);\n&#125;\nint M3(int q[], int l, int r) &#123;\n    &#x2F;&#x2F;计算数组中间的元素的下标\n    int mid &#x3D; (r + l) &#x2F; 2;\n    &#x2F;&#x2F;使用三数中值法选择枢轴\n    if (q[l] &gt; q[r])\n        swap_arr_elm(q, l, r);\n    if (q[mid] &gt; q[r])\n        swap_arr_elm(q, mid, r);\n    if (q[mid] &gt; q[l])\n        swap_arr_elm(q, mid, l);\n    &#x2F;&#x2F;此时，arr[mid] &lt;&#x3D; arr[l] &lt;&#x3D; arr[r],low的位置上保存这三个位置中间的值\n    return q[l];\n&#125;</code></pre>\n\n<p>​       上述代码已通过LeetCode、洛谷及牛客等OJ平台的算例测试，可放心食用。</p>\n<p>​       另外，STL源码中的sort方法虽然主要基于快速排序，但对于小区间(临界元素个数为16)会改用插入排序，且在递归层次过深时利用的是堆排序。</p>\n","feature":true,"text":"快速排序 1.确定pivot(基准值)，一般选择区间右端点； 2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot； 3.利用递归实现区间排序。 利用双指针法实现区间划分​ 左指针从左到右找到第一个不小于基准值的元素，右指针从...","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":3,"path":"api/tags/AcWing算法基础课.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">快速排序</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%A9%E7%94%A8%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%8C%BA%E9%97%B4%E5%88%92%E5%88%86\"><span class=\"toc-text\">利用双指针法实现区间划分</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%80%83%E8%99%91%E6%95%B0%E6%8D%AE%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7%E7%9A%84%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">考虑数据不确定性的算法优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Random\"><span class=\"toc-text\">Random</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Median-Of-Three\"><span class=\"toc-text\">Median-Of-Three</span></a></li></ol></li></ol></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"A2-二分","uid":"7092e7a06827631ebc7687e38da9f572","slug":"A2-二分","date":"2022-10-01T09:46:09.000Z","updated":"2022-10-03T04:49:16.187Z","comments":true,"path":"api/articles/A2-二分.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600098.jpg","text":"","link":"","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":3,"path":"api/tags/AcWing算法基础课.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true},"next_post":{}}