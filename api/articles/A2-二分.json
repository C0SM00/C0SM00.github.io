{"title":"A2-二分","uid":"7092e7a06827631ebc7687e38da9f572","slug":"A2-二分","date":"2022-10-01T09:46:09.000Z","updated":"2022-10-29T08:46:30.630Z","comments":true,"path":"api/articles/A2-二分.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600098.jpg","content":"<h3 id=\"整数二分\"><a href=\"#整数二分\" class=\"headerlink\" title=\"整数二分\"></a>整数二分</h3><div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">二分问题的本质</p>\n<p>基于某个预设条件，可将区间划分为两个连续的状态区间(满足/不满足)，问题的答案就在区间的边界上。</p>\n\n</div>\n<h4 id=\"两种二分模板\"><a href=\"#两种二分模板\" class=\"headerlink\" title=\"两种二分模板\"></a>两种二分模板</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">// 模板1：区间[l, r]被划分为[l, mid]和[mid + 1, r]\nint bin_search_1(int l, int r) {\n    while(l &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if(check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 模板2：区间[l, r]被划分成[l, mid - 1]和[mid, r]\nint bin_search_2(int l, int r) {\n    while(l &lt; r) {\n        // Warning:此处mid应取右，否则当l=r-1时左边界取左会陷入死循环\n\t\tint mid = l + r + 1 &gt;&gt; 1;\n        if(check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}</code></pre>\n\n<h4 id=\"模板的选择\"><a href=\"#模板的选择\" class=\"headerlink\" title=\"模板的选择\"></a>模板的选择</h4><p><img src=\"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210042132836.png\" alt=\"整数二分示意图\"></p>\n<p>边界 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"0.674ex\" height=\"1.595ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 298 705\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g></g></g></svg></mjx-container> 和 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.02ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 451 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container> 怎么更新，取决于目标答案是 ans1 还是 ans2，当 mid 落在右区间时，mid 可能就是 ans2 ，那么在寻找 ans2 时右边界 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.025ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"1.02ex\" height=\"1.025ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -442 451 453\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mi\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g></g></g></svg></mjx-container> 应更新为 mid，反之在寻找 ans1 时右边界应更新为 mid - 1。确定题目的目标是 ans1 还是ans2 只需要判断答案是否满足预设条件。</p>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">解题关键</p>\n<p><p>-确定区间的划分条件</p>\n<p>-确定区间边界的更新方式</p>\n<p>-根据更新方式确定mid的计算方式(取左还是取右)</p>\n</p>\n</div>\n<hr>\n<h3 id=\"浮点数二分\"><a href=\"#浮点数二分\" class=\"headerlink\" title=\"浮点数二分\"></a>浮点数二分</h3><p>浮点数二分不需要考虑边界条件，只需要设定答案精度作为迭代停止的条件。</p>\n","feature":false,"text":"整数二分 二分问题的本质 基于某个预设条件，可将区间划分为两个连续的状态区间(满足/不满足)，问题的答案就在区间的边界上。 两种二分模板// 模板1：区间[l, r]被划分为[l, mid]和[mid + 1, r] int bin_search_1(int l, int r) ...","link":"","photos":[],"count_time":{"symbolsCount":812,"symbolsTime":"1 mins."},"categories":[{"name":"算法","slug":"算法","count":4,"path":"api/categories/算法.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":5,"path":"api/tags/AcWing算法基础课.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">整数二分</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E4%BA%8C%E5%88%86%E6%A8%A1%E6%9D%BF\"><span class=\"toc-text\">两种二分模板</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%80%89%E6%8B%A9\"><span class=\"toc-text\">模板的选择</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%AE%E7%82%B9%E6%95%B0%E4%BA%8C%E5%88%86\"><span class=\"toc-text\">浮点数二分</span></a></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"A3-高精度","uid":"6940eb2ba483d3d0018fcb9e180da589","slug":"A3-高精度","date":"2022-10-01T09:46:35.000Z","updated":"2022-10-29T08:46:39.745Z","comments":true,"path":"api/articles/A3-高精度.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600973.jpg","text":"高精度 TIP c++ 中 unsigned long long 的数量级是 ，因此超过该数量级的数值处理就要涉及高精度运算。 大数存储为方便处理进位，将大数在数组中逆序存储。 int main() { string s1, s2; vector&lt;int&gt; num1,...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":4,"path":"api/categories/算法.json"}],"tags":[{"name":"AcWing算法基础课","slug":"AcWing算法基础课","count":5,"path":"api/tags/AcWing算法基础课.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":false},"next_post":{}}