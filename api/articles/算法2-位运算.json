{"title":"算法2-位运算","uid":"23b460b1d81bc84883e4eda5dcad0a53","slug":"算法2-位运算","date":"2022-10-01T09:46:09.000Z","updated":"2022-10-02T08:00:27.759Z","comments":true,"path":"api/articles/算法2-位运算.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600098.jpg","content":"<h3 id=\"1-异或\"><a href=\"#1-异或\" class=\"headerlink\" title=\"(1)异或(^)\"></a>(1)异或(^)</h3><h4 id=\"Leetcode-17-04-消失的数\"><a href=\"#Leetcode-17-04-消失的数\" class=\"headerlink\" title=\"Leetcode 17.04 消失的数\"></a><u>Leetcode 17.04 消失的数</u></h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？</p></blockquote>\n<p>**1.**异或运算的特性：计算机中两个数（补码）按位进行异或；</p>\n<p>​\t\t\t\t\t\t\t\t两个相同的数异或等于0；</p>\n<p>​\t\t\t\t\t\t\t\t任何数与0异或结果还是那个数。</p>\n<p>&#x3D;&#x3D;&gt; <code>a^b^c^c^b=a</code>，两对相同的数异或之后等于0，再与只有单个的数异或还等于那个数。</p>\n<p>**2.**ans的初始值设为0，所以for循环只需要1 - n。对于样例[3，0，1]，相当于<code>0^1^3^2^0^3^1=2</code>。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n    int n&#x3D;nums.size(),ans&#x3D;0;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        ans^&#x3D;i;\n        ans^&#x3D;nums[i-1];\n    &#125;\n    return ans;\n&#125;</code></pre>\n\n<h4 id=\"改编1（寻找两个唯一的数）\"><a href=\"#改编1（寻找两个唯一的数）\" class=\"headerlink\" title=\"改编1（寻找两个唯一的数）\"></a>改编1（寻找两个唯一的数）</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>现在把难度升级一下，若数组里存在两个唯一的数，该怎么把它找出来呢？按照之前的方法，只能得到 <code>n1^n2</code>，拿不到独立的数。</p></blockquote>\n<p>n1跟n2是不同的数，那么在它们二进制的表示上，至少有一位是不一样的，那我们可以根据这一位上是1还是0把数组里的数分成两拨，这两个数肯定就在各自的分组里，然后相同的数也肯定在同一个分组里，再让这两拨数做异或运算，最后各自剩下来的就是我们要的两个数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">public static int[] findSingleNumbers(int[] nums) &#123;\n    int n1xn2 &#x3D; 0;\n    for (int num : nums) &#123;\n        n1xn2 ^&#x3D; num;\n    &#125;\n    &#x2F;&#x2F;n1xn2为两个唯一数异或的结果\n    int rightmostSetBit &#x3D; 1;\n    &#x2F;&#x2F;通过与运算和移位运算从右往左找到第一个不同的位进行分组\n    while ((rightmostSetBit &amp; n1xn2) &#x3D;&#x3D; 0) &#123;\n        rightmostSetBit &#x3D; rightmostSetBit &lt;&lt; 1;\n    &#125;\n    int num1 &#x3D; 0, num2 &#x3D; 0;\n    for (int num : nums) &#123;\n        if ((num &amp; rightmostSetBit) !&#x3D; 0)\n            num1 ^&#x3D; num;\n        else\n            num2 ^&#x3D; num;\n    &#125;\n    return new int[]&#123;num1, num2&#125;;\n&#125;</code></pre>\n\n<h4 id=\"改编2（寻找一个重复的数）\"><a href=\"#改编2（寻找一个重复的数）\" class=\"headerlink\" title=\"改编2（寻找一个重复的数）\"></a>改编2（寻找一个重复的数）</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p></blockquote>\n<p>我们发现在查找“奇数个”的数据的时候，异或运算用起来还是非常方便的。因此不妨将数字1-n和数组nums异或，结果只有重复两次的数字异或了三次（奇数次），剩下的就是重复的数字。</p>\n<h4 id=\"其他应用\"><a href=\"#其他应用\" class=\"headerlink\" title=\"其他应用\"></a>其他应用</h4><ul>\n<li><p>交换两个数</p>\n<p>优点是少了一个临时变量，执行效率也比较高。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void swap(ref int a, ref int b)&#123;\n    a ^&#x3D; b;\n    b ^&#x3D; a;\n    a ^&#x3D; b;\n&#125;</code></pre>\n\n<ul>\n<li><p>备份硬盘</p>\n<p>有 N + 1 块相同容量的硬盘，其中 N 块用来存储数据，如果利用多余的 1 块硬盘来存储 N 块硬盘的数据备份，假设硬盘最多同时只会损坏 1 块。多余的 1 块硬盘存储 N 块硬盘异或的结果，那么当其中 1 块硬盘损坏的时候，只需要把其他好的硬盘数据再异或一遍，即可得到损坏的硬盘的数据了。</p>\n</li>\n<li><p>加密数据</p>\n<p>加密：明文^密钥&#x3D;密文 ，解密：密文^密钥&#x3D;明文。</p>\n</li>\n</ul>\n<h3 id=\"2-与-amp\"><a href=\"#2-与-amp\" class=\"headerlink\" title=\"(2)与(&amp;)\"></a>(2)与(&amp;)</h3><h4 id=\"Leetcode-2154-将找到的值乘以-2\"><a href=\"#Leetcode-2154-将找到的值乘以-2\" class=\"headerlink\" title=\"Leetcode 2154 将找到的值乘以 2\"></a><u>Leetcode 2154 将找到的值乘以 2</u></h4><ul>\n<li><p>判断一个数是否为2的幂次</p>\n<p>如果一个数是2的幂次，那么它的二进制中有且仅有一位是 1，那么&#x3D;&#x3D;k &amp; (k - 1)&#x3D;&#x3D;的结果是 0。以k &#x3D; 16为例，其二进制为 1 0000，k - 1的二进制为 0 1111， 1 0000 &amp; 0 1111 &#x3D; 0 0000。</p>\n<p>所以要判断一个数是不是2的幂次，只要将这个数和其减一相与，若结果为0则是，反之则否。</p>\n</li>\n</ul>\n","feature":true,"text":"(1)异或(^)Leetcode 17.04 消失的数 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？ **1.**异或运算的特性：计算机中两个数（补码）按位进行异或； ​ 两个相同的数异或等于0； ​ 任何数与...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%BC%82%E6%88%96\"><span class=\"toc-text\">(1)异或(^)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-17-04-%E6%B6%88%E5%A4%B1%E7%9A%84%E6%95%B0\"><span class=\"toc-text\">Leetcode 17.04 消失的数</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%94%B9%E7%BC%961%EF%BC%88%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E6%95%B0%EF%BC%89\"><span class=\"toc-text\">改编1（寻找两个唯一的数）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%94%B9%E7%BC%962%EF%BC%88%E5%AF%BB%E6%89%BE%E4%B8%80%E4%B8%AA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%EF%BC%89\"><span class=\"toc-text\">改编2（寻找一个重复的数）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8\"><span class=\"toc-text\">其他应用</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E4%B8%8E-amp\"><span class=\"toc-text\">(2)与(&amp;)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-2154-%E5%B0%86%E6%89%BE%E5%88%B0%E7%9A%84%E5%80%BC%E4%B9%98%E4%BB%A5-2\"><span class=\"toc-text\">Leetcode 2154 将找到的值乘以 2</span></a></li></ol></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"算法3-双指针法","uid":"aa93ace04152e302fb9ecfb0c5ff3fc0","slug":"算法3-双指针法","date":"2022-10-01T09:46:35.000Z","updated":"2022-10-02T08:01:00.052Z","comments":true,"path":"api/articles/算法3-双指针法.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600973.jpg","text":"(1)快慢指针Leetcode 27 移除元素 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 数组在内存中是连续的地址空间，不能简单地删...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"双指针法","slug":"双指针法","count":1,"path":"api/tags/双指针法.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true},"next_post":{}}