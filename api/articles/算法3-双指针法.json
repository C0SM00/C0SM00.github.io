{"title":"算法3-双指针法","uid":"aa93ace04152e302fb9ecfb0c5ff3fc0","slug":"算法3-双指针法","date":"2022-10-01T09:46:35.000Z","updated":"2022-10-02T08:01:00.052Z","comments":true,"path":"api/articles/算法3-双指针法.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600973.jpg","content":"<h3 id=\"1-快慢指针\"><a href=\"#1-快慢指针\" class=\"headerlink\" title=\"(1)快慢指针\"></a>(1)快慢指针</h3><h4 id=\"Leetcode-27-移除元素\"><a href=\"#Leetcode-27-移除元素\" class=\"headerlink\" title=\"Leetcode 27 移除元素\"></a>Leetcode 27 移除元素</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须<strong>仅使用 O(1) 额外空间并原地修改输入数组</strong>。</p></blockquote>\n<ul>\n<li>数组在内存中是连续的地址空间，不能简单地删除或释放单一元素。若对数组中的某个元素进行删除，需要进行顺序查找和移位，for嵌套循环的时间复杂度是O(n^2)。**&#x3D;&#x3D;静态数组的元素不能删除，只能进行覆盖。&#x3D;&#x3D;**</li>\n</ul>\n<p>![双指针法](C:\\Users\\Berton\\Pictures\\Camera Roll\\008eGmZEly1gntrds6r59g30du09mnpd.gif)</p>\n<pre class=\"line-numbers language-c\" data-language=\"c\"><code class=\"language-c\">int removeElement(int* nums, int numsSize, int val)&#123;\n    int slowindex&#x3D;0;\n    for(int fastindex&#x3D;0;fastindex&lt;numsSize;fastindex++)\n        if(nums[fastindex]!&#x3D;val)\n            nums[slowindex++]&#x3D;nums[fastindex];\n    return slowindex;\n&#125;</code></pre>\n\n<hr>\n<h4 id=\"Leetcode-26-删除排序数组中的重复项\"><a href=\"#Leetcode-26-删除排序数组中的重复项\" class=\"headerlink\" title=\"Leetcode 26 删除排序数组中的重复项\"></a>Leetcode 26 删除排序数组中的重复项</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。</p></blockquote>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n&#x3D;&#x3D;0)\n            return 0;\n        int slowindex &#x3D; 0;\n        for(int fastindex &#x3D; 0;fastindex &lt; n;fastindex++)&#123;\n            if(nums[fastindex]!&#x3D;nums[slowindex])&#123;\n                nums[++slowindex]&#x3D;nums[fastindex];\n            &#125;\n        &#125;\n        return slowindex+1;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h4 id=\"Leetcode-19-删除链表的倒数第N个节点\"><a href=\"#Leetcode-19-删除链表的倒数第N个节点\" class=\"headerlink\" title=\"Leetcode 19 删除链表的倒数第N个节点\"></a>Leetcode 19 删除链表的倒数第N个节点</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给定一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点（使用一趟扫描实现）。</p></blockquote>\n<ul>\n<li>定义fast指针和slow指针，初始值为虚拟头结点，让fast先走n+1步，然后同时移动fast和slow（保持fast与slow间隔n+1个位置），那么当fast指向末尾的<code>nullptr</code>时，slow指向要删除的节点的前一个位置。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\"> struct ListNode &#123;\n    int val;\n \tListNode *next;\n    ListNode() : val(0), next(nullptr) &#123;&#125;\n    ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n &#125;;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode* dummyHead &#x3D; new ListNode(0);\n        dummyHead-&gt;next &#x3D; head;\n        ListNode* slow &#x3D; dummyHead;\n        ListNode* fast &#x3D; dummyHead;\n        while(n-- &amp;&amp; fast !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next;\n        &#125;\n        fast &#x3D; fast-&gt;next; &#x2F;&#x2F; fast再提前走一步，因为需要让slow指向删除节点的上一个节点\n        while (fast !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        slow-&gt;next &#x3D; slow-&gt;next-&gt;next;\n        return dummyHead-&gt;next;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h3 id=\"2-有序数组性质\"><a href=\"#2-有序数组性质\" class=\"headerlink\" title=\"(2)有序数组性质\"></a>(2)有序数组性质</h3><h4 id=\"Leetcode-88-合并两个有序数组\"><a href=\"#Leetcode-88-合并两个有序数组\" class=\"headerlink\" title=\"Leetcode 88 合并两个有序数组\"></a>Leetcode 88 合并两个有序数组</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。</p>\n<p>请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。</p>\n<p>注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3\n输出：[1,2,2,3,5,6]</code></pre>\n\n<ul>\n<li><p>双指针：分别用指针p1、p2遍历数组nums1和nums2，每次将两者中较大的数据放入临时数组中。</p>\n</li>\n<li><p>逆向双指针：从头插入的情况容易覆盖原数组的数据，所以需要临时变量来储存排列后的数据；但由于nums1后半部分数据为空，可以让指针从后向前遍历，每次把两者中的较大放在数组的后面。</p>\n<p>![证明](C:\\Users\\Berton\\Pictures\\Camera Roll\\image-20211017192758089.png)</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;\n        int p1 &#x3D; m - 1, p2 &#x3D; n - 1;\n        int tail &#x3D; m + n - 1;\n        int cur;\n        while (p1 &gt;&#x3D; 0 || p2 &gt;&#x3D; 0) &#123;\n            if (p1 &#x3D;&#x3D; -1) &#123;\n                cur &#x3D; nums2[p2--];\n            &#125; else if (p2 &#x3D;&#x3D; -1) &#123;\n                cur &#x3D; nums1[p1--];\n            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;\n                cur &#x3D; nums1[p1--];\n            &#125; else &#123;\n                cur &#x3D; nums2[p2--];\n            &#125;\n            nums1[tail--] &#x3D; cur;\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h4 id=\"Leetcode-977-有序数组的平方\"><a href=\"#Leetcode-977-有序数组的平方\" class=\"headerlink\" title=\"Leetcode 977 有序数组的平方\"></a>Leetcode 977 有序数组的平方</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p></blockquote>\n <pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]</code></pre>\n\n<ul>\n<li>原数组有序，只不过可能有负数平方后成为最大数，即&#x3D;&#x3D;最大数只可能在数组两端&#x3D;&#x3D;。可以用前后两个指针进行遍历，两者中的较大数放在数组的最后面。</li>\n</ul>\n<hr>\n<h3 id=\"3-原地替换（从后端空位开始填充）\"><a href=\"#3-原地替换（从后端空位开始填充）\" class=\"headerlink\" title=\"(3)原地替换（从后端空位开始填充）\"></a>(3)原地替换（从后端空位开始填充）</h3><h4 id=\"剑指-Offer-05-替换空格\"><a href=\"#剑指-Offer-05-替换空格\" class=\"headerlink\" title=\"剑指 Offer 05. 替换空格\"></a>剑指 Offer 05. 替换空格</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>请实现一个函数，把字符串 <code>s</code> 中的每个空格替换成”%20”。</p></blockquote>\n<ul>\n<li>先将字符串**&#x3D;&#x3D;扩容&#x3D;&#x3D;<strong>成替换空格后的长度，然后</strong>&#x3D;&#x3D;利用双指针从后向前填充&#x3D;&#x3D;**。如果从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将之后的所有元素向后移动。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    string replaceSpace(string s) &#123;\n        int count &#x3D; 0; &#x2F;&#x2F; 统计空格的个数\n        int sOldSize &#x3D; s.size();\n        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if (s[i] &#x3D;&#x3D; &#39; &#39;) \n                count++;\n        &#125;\n        &#x2F;&#x2F; 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小\n        s.resize(s.size() + count * 2);\n        int sNewSize &#x3D; s.size();\n        &#x2F;&#x2F; 从后先前将空格替换为&quot;%20&quot;\n        for (int i &#x3D; sNewSize - 1, j &#x3D; sOldSize - 1; j &lt; i; i--, j--) &#123;\n            if (s[j] !&#x3D; &#39; &#39;) &#123;\n                s[i] &#x3D; s[j];\n            &#125; else &#123;\n                s[i] &#x3D; &#39;0&#39;;\n                s[i - 1] &#x3D; &#39;2&#39;;\n                s[i - 2] &#x3D; &#39;%&#39;;\n                i -&#x3D; 2;\n            &#125;\n        &#125;\n        return s;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h3 id=\"4-滑动窗口（尺取法-x2F-单调队列）\"><a href=\"#4-滑动窗口（尺取法-x2F-单调队列）\" class=\"headerlink\" title=\"(4)滑动窗口（尺取法&#x2F;单调队列）\"></a>(4)滑动窗口（尺取法&#x2F;单调队列）</h3><h4 id=\"Leetcode-209-长度最小的子数组\"><a href=\"#Leetcode-209-长度最小的子数组\" class=\"headerlink\" title=\"Leetcode 209 长度最小的子数组\"></a>Leetcode 209 长度最小的子数组</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>\n<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p></blockquote>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。</code></pre>\n\n<ul>\n<li><h5 id=\"算法思想\"><a href=\"#算法思想\" class=\"headerlink\" title=\"算法思想\"></a>算法思想</h5>1、在序列中使用双指针中的左右指针技巧，初始化 start &#x3D; end &#x3D; 0，把索引闭区间 [start, end] 称为一个窗口。<br>2、先不断地增加 end 指针扩大窗口 [start, end]，直到窗口中的序列符合要求。<br>3、此时，停止增加 end，转而不断增加 start 指针缩小窗口 [start, end]，直到窗口中的序列不再符合要求。同时，每次增加 start 前，都要更新一轮结果。<br>4、重复第 2 和第 3 步，直到 end 到达序列的尽头。</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int ans &#x3D; INT_MAX;\n        int start &#x3D; 0, end &#x3D; 0;\n        int sum &#x3D; 0;\n        while (end &lt; n) &#123;  &#x2F;&#x2F;数组最后一个下标是n-1\n            sum +&#x3D; nums[end];\n            while (sum &gt;&#x3D; s) &#123;\n                ans &#x3D; min(ans, end - start + 1);\n                sum -&#x3D; nums[start++];\n            &#125;\n            end++;\n        &#125;\n        return ans &#x3D;&#x3D; INT_MAX ? 0 : ans;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h4 id=\"满足条件的连续子序列\"><a href=\"#满足条件的连续子序列\" class=\"headerlink\" title=\"满足条件的连续子序列\"></a>满足条件的连续子序列</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你长度为 n 的数组 a 和一个正整数 k ，问你 a 有多少个和大于等于 k 的<strong>连续</strong>子序列。</p></blockquote>\n<ul>\n<li><h5 id=\"x3D-x3D-如果连续子序列-l-r-的和已经-gt-x3D-k，那么从l到r-1-r-2……的和都大于k，这样的子序列一共有n-r-1。-x3D-x3D\"><a href=\"#x3D-x3D-如果连续子序列-l-r-的和已经-gt-x3D-k，那么从l到r-1-r-2……的和都大于k，这样的子序列一共有n-r-1。-x3D-x3D\" class=\"headerlink\" title=\"&#x3D;&#x3D;如果连续子序列[l , r]的和已经&gt;&#x3D;k，那么从l到r+1,r+2……的和都大于k，这样的子序列一共有n-r+1。&#x3D;&#x3D;\"></a>&#x3D;&#x3D;如果连续子序列[l , r]的和已经&gt;&#x3D;k，那么从l到r+1,r+2……的和都大于k，这样的子序列一共有n-r+1。&#x3D;&#x3D;</h5><p>那么只要从0—n-1遍历所有的l，对于一个给定的l，&#x3D;&#x3D;找出最小的r&#x3D;&#x3D;使得∑[l,r]&gt;&#x3D;k。</p>\n<p>对于给定的l，可以用类似&#x3D;&#x3D;滑动窗口&#x3D;&#x3D;的方式快速求出最小的r：若前一个l已经找到满足条件的最小的r，则只需要从前一次的和中减去a[l],得到的就是l+1—r的和。如果这个和大于k，那么r仍然最小的；若和小于k，则r向右移动，直到和重新大于k。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nll a[100010];\nint main() &#123;\n    int n;\n    ll k;\n    cin &gt;&gt; n &gt;&gt; k; &#x2F;&#x2F; 数组长度为n，要大于等于的数是k\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n    &#125;\n    ll ans &#x3D; 0; &#x2F;&#x2F; 答案\n    ll left &#x3D; 0, right &#x3D; 0;   &#x2F;&#x2F; l和r初始值都是0\n    ll sum &#x3D; a[0];            &#x2F;&#x2F; sum代表[left, right]的和\n    while (right &lt; n) &#123;       &#x2F;&#x2F; 右边r还未移出数组时\n        if (sum &gt;&#x3D; k) &#123;       &#x2F;&#x2F; sum[l, r] &gt;&#x3D; k\n            ans +&#x3D; n - right; \n&#x2F;&#x2F; 此时就是在对应l下，最小的满足题意的r。sum[l, r] &gt;&#x3D; k, sum[l, r + 1] &gt;&#x3D; k ...             \t sum[l, n - 1] &gt;&#x3D; k（输入的时候数组存储下标是0~n-1，比题解中1~n小1）\n            sum -&#x3D; a[left++]; &#x2F;&#x2F; 枚举下一个l（l++），相应地sum也要减去不在范围内的a[l]\n        &#125; else &#123;              &#x2F;&#x2F; sum[l, r] &lt; k，还没找到最小的r\n            sum +&#x3D; a[++right]; &#x2F;&#x2F; r右移并累加入总和\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return 0;</code></pre>\n\n\n\n<hr>\n<h3 id=\"5-翻转问题\"><a href=\"#5-翻转问题\" class=\"headerlink\" title=\"(5)翻转问题\"></a>(5)翻转问题</h3><h4 id=\"Leetcode-344-反转字符串\"><a href=\"#Leetcode-344-反转字符串\" class=\"headerlink\" title=\"Leetcode 344 反转字符串\"></a>Leetcode 344 反转字符串</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。</p>\n<p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p></blockquote>\n<img src=\"C:\\Users\\Berton\\Pictures\\Camera Roll\\008eGmZEly1gp0fvi91pfg30de0akwnq.gif\" alt=\"344.反转字符串\" style=\"zoom: 50%;\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) &#123;\n        for (int i &#x3D; 0,j &#x3D; s.size() - 1;i &lt; s.size()&#x2F;2;i++,j--) &#123;\n            swap(s[i],s[j]);\n        &#125;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h3 id=\"6-指针相遇\"><a href=\"#6-指针相遇\" class=\"headerlink\" title=\"(6)指针相遇\"></a>(6)指针相遇</h3><h4 id=\"链表相交\"><a href=\"#链表相交\" class=\"headerlink\" title=\"链表相交\"></a>链表相交</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 <code>null</code> 。</p></blockquote>\n<ul>\n<li>从头节点headA和headB开始分别遍历链表，**&#x3D;&#x3D;如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历&#x3D;&#x3D;**；若链表相交，在遍历完两个链表时指针一定相遇。若两个结点不相交，则将会同时到达NULL。</li>\n</ul>\n<img src=\"C:\\Users\\Berton\\Pictures\\Camera Roll\\format,png\" alt=\"image.png\" style=\"zoom: 67%;\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        ListNode* a &#x3D; headA;\n        ListNode* b &#x3D; headB;\n        while (a !&#x3D; b)\n        &#123;\n            a &#x3D; a !&#x3D; nullptr ? a-&gt;next : headB;\n            b &#x3D; b !&#x3D; nullptr ? b-&gt;next : headA;\n        &#125;\n        return a;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h3 id=\"7-排序和双指针优化双重遍历\"><a href=\"#7-排序和双指针优化双重遍历\" class=\"headerlink\" title=\"(7)排序和双指针优化双重遍历\"></a>(7)排序和双指针优化双重遍历</h3><h4 id=\"Leetcode-15-三数之和\"><a href=\"#Leetcode-15-三数之和\" class=\"headerlink\" title=\"Leetcode 15 三数之和\"></a>Leetcode 15 三数之和</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</p></blockquote>\n<ul>\n<li><p>将数组非降序排序，然后对 i 进行遍历，同时定义left &#x3D; i+1，right &#x3D; n-1，相当于把三数之和转换成了两数之和——nums[left]+nums[right]&#x3D;&#x3D;-nums[i]；</p>\n<p>如果 nums[left] + nums[right] &gt; -nums[i] ，说明此时两数之和过大，right需要左移，反之left右移。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">class Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(nums.begin(), nums.end());\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            &#x2F;&#x2F; 非降序排序后如果第一个元素大于零，那么不存在等于0的三元和\n            if (nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n            &#x2F;&#x2F; 错误去重方法，将会漏掉-1,-1,2 这种情况\n            &#x2F;*\n            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;\n                continue;\n            &#125;\n            *&#x2F;\n            &#x2F;&#x2F; 正确去重方法\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n            int left &#x3D; i + 1;\n            int right &#x3D; nums.size() - 1;\n            while (right &gt; left) &#123;\n                &#x2F;&#x2F; 去重复逻辑如果放在这里，样例[0,0,0]会因为right&lt;&#x3D;left，漏掉[0,0,0]的答案\n                &#x2F;*\n                while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n                *&#x2F;\n                if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;\n                    right--;\n                &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;\n                    left++;\n                &#125; else &#123;\n                    result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);\n                    &#x2F;&#x2F; 去重逻辑应该放在找到一个三元组之后\n                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n                    &#x2F;&#x2F; 找到答案时，双指针同时收缩\n                    right--;\n                    left++;\n                &#125;\n            &#125;\n\n        &#125;\n        return result;\n    &#125;\n&#125;;</code></pre>\n\n<hr>\n<h4 id=\"Leetcode-18-四数之和\"><a href=\"#Leetcode-18-四数之和\" class=\"headerlink\" title=\"Leetcode 18 四数之和\"></a>Leetcode 18 四数之和</h4><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）</p></blockquote>\n<ul>\n<li>四数之和的双指针解法是两层for循环 nums[k] + nums[i] 为确定值，依然是循环内有 left 和 right 下表作为双指针，找出 nums[left] + nums[right] &#x3D;&#x3D; target - nums[k] - nums[i] 的情况，四数之和的时间复杂度是O(n^3) 。<strong>双指针法可以将时间复杂度相对于暴力枚举降一个数量级。</strong></li>\n</ul>\n<hr>\n<h4 id=\"在序列中寻找不相等数字的最大距离\"><a href=\"#在序列中寻找不相等数字的最大距离\" class=\"headerlink\" title=\"在序列中寻找不相等数字的最大距离\"></a>在序列中寻找不相等数字的最大距离</h4><ul>\n<li>设置头尾指针，即从最大长度开始遍历，在不断缩小长度的过程中最先找到的不相等数字距离最大。</li>\n</ul>\n<hr>\n","feature":true,"text":"(1)快慢指针Leetcode 27 移除元素 给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。 数组在内存中是连续的地址空间，不能简单地删...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"双指针法","slug":"双指针法","count":1,"path":"api/tags/双指针法.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88\"><span class=\"toc-text\">(1)快慢指针</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0\"><span class=\"toc-text\">Leetcode 27 移除元素</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9\"><span class=\"toc-text\">Leetcode 26 删除排序数组中的重复项</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9\"><span class=\"toc-text\">Leetcode 19 删除链表的倒数第N个节点</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E6%80%A7%E8%B4%A8\"><span class=\"toc-text\">(2)有序数组性质</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-88-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">Leetcode 88 合并两个有序数组</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9\"><span class=\"toc-text\">Leetcode 977 有序数组的平方</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%9F%E5%9C%B0%E6%9B%BF%E6%8D%A2%EF%BC%88%E4%BB%8E%E5%90%8E%E7%AB%AF%E7%A9%BA%E4%BD%8D%E5%BC%80%E5%A7%8B%E5%A1%AB%E5%85%85%EF%BC%89\"><span class=\"toc-text\">(3)原地替换（从后端空位开始填充）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%89%91%E6%8C%87-Offer-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC\"><span class=\"toc-text\">剑指 Offer 05. 替换空格</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%88%E5%B0%BA%E5%8F%96%E6%B3%95-x2F-%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%EF%BC%89\"><span class=\"toc-text\">(4)滑动窗口（尺取法&#x2F;单调队列）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">Leetcode 209 长度最小的子数组</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3\"><span class=\"toc-text\">算法思想</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97\"><span class=\"toc-text\">满足条件的连续子序列</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#x3D-x3D-%E5%A6%82%E6%9E%9C%E8%BF%9E%E7%BB%AD%E5%AD%90%E5%BA%8F%E5%88%97-l-r-%E7%9A%84%E5%92%8C%E5%B7%B2%E7%BB%8F-gt-x3D-k%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BB%8El%E5%88%B0r-1-r-2%E2%80%A6%E2%80%A6%E7%9A%84%E5%92%8C%E9%83%BD%E5%A4%A7%E4%BA%8Ek%EF%BC%8C%E8%BF%99%E6%A0%B7%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E4%B8%80%E5%85%B1%E6%9C%89n-r-1%E3%80%82-x3D-x3D\"><span class=\"toc-text\">&#x3D;&#x3D;如果连续子序列[l , r]的和已经&gt;&#x3D;k，那么从l到r+1,r+2……的和都大于k，这样的子序列一共有n-r+1。&#x3D;&#x3D;</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-%E7%BF%BB%E8%BD%AC%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">(5)翻转问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2\"><span class=\"toc-text\">Leetcode 344 反转字符串</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-%E6%8C%87%E9%92%88%E7%9B%B8%E9%81%87\"><span class=\"toc-text\">(6)指针相遇</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4\"><span class=\"toc-text\">链表相交</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8F%8C%E6%8C%87%E9%92%88%E4%BC%98%E5%8C%96%E5%8F%8C%E9%87%8D%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">(7)排序和双指针优化双重遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">Leetcode 15 三数之和</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Leetcode-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C\"><span class=\"toc-text\">Leetcode 18 四数之和</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9C%A8%E5%BA%8F%E5%88%97%E4%B8%AD%E5%AF%BB%E6%89%BE%E4%B8%8D%E7%9B%B8%E7%AD%89%E6%95%B0%E5%AD%97%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB\"><span class=\"toc-text\">在序列中寻找不相等数字的最大距离</span></a></li></ol></li></ol>","author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"算法2-位运算","uid":"23b460b1d81bc84883e4eda5dcad0a53","slug":"算法2-位运算","date":"2022-10-01T09:46:09.000Z","updated":"2022-10-02T08:00:27.759Z","comments":true,"path":"api/articles/算法2-位运算.json","keywords":"","cover":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021600098.jpg","text":"(1)异或(^)Leetcode 17.04 消失的数 数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？ **1.**异或运算的特性：计算机中两个数（补码）按位进行异或； ​ 两个相同的数异或等于0； ​ 任何数与...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法","slug":"算法","count":3,"path":"api/categories/算法.json"}],"tags":[{"name":"位运算","slug":"位运算","count":1,"path":"api/tags/位运算.json"}],"author":{"name":"MiF","slug":"blog-author","avatar":"https://blog-img-mif-1314191311.cos.ap-nanjing.myqcloud.com/images/202210021426303.png","link":"/","description":"CS Learner","socials":{"github":"https://github.com/C0SM00","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/xian-xian-19-81","csdn":"https://blog.csdn.net/ReSeT_H","juejin":"","customs":{}}},"feature":true}}