[{"id":"aa93ace04152e302fb9ecfb0c5ff3fc0","title":"算法3-双指针法","content":"(1)快慢指针Leetcode 27 移除元素\n\n\n\n\n\n\n\n\n给你一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并原地修改输入数组。\n\n数组在内存中是连续的地址空间，不能简单地删除或释放单一元素。若对数组中的某个元素进行删除，需要进行顺序查找和移位，for嵌套循环的时间复杂度是O(n^2)。**&#x3D;&#x3D;静态数组的元素不能删除，只能进行覆盖。&#x3D;&#x3D;**\n\n![双指针法](C:\\Users\\Berton\\Pictures\\Camera Roll\\008eGmZEly1gntrds6r59g30du09mnpd.gif)\nint removeElement(int* nums, int numsSize, int val)&#123;\n    int slowindex&#x3D;0;\n    for(int fastindex&#x3D;0;fastindex&lt;numsSize;fastindex++)\n        if(nums[fastindex]!&#x3D;val)\n            nums[slowindex++]&#x3D;nums[fastindex];\n    return slowindex;\n&#125;\n\n\nLeetcode 26 删除排序数组中的重复项\n\n\n\n\n\n\n\n\n给你一个有序数组 nums ，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。\nclass Solution &#123;\npublic:\n    int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if(n&#x3D;&#x3D;0)\n            return 0;\n        int slowindex &#x3D; 0;\n        for(int fastindex &#x3D; 0;fastindex &lt; n;fastindex++)&#123;\n            if(nums[fastindex]!&#x3D;nums[slowindex])&#123;\n                nums[++slowindex]&#x3D;nums[fastindex];\n            &#125;\n        &#125;\n        return slowindex+1;\n    &#125;\n&#125;;\n\n\nLeetcode 19 删除链表的倒数第N个节点\n\n\n\n\n\n\n\n\n给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点（使用一趟扫描实现）。\n\n定义fast指针和slow指针，初始值为虚拟头结点，让fast先走n+1步，然后同时移动fast和slow（保持fast与slow间隔n+1个位置），那么当fast指向末尾的nullptr时，slow指向要删除的节点的前一个位置。\n\n struct ListNode &#123;\n    int val;\n \tListNode *next;\n    ListNode() : val(0), next(nullptr) &#123;&#125;\n    ListNode(int x) : val(x), next(nullptr) &#123;&#125;\n    ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;\n &#125;;\nclass Solution &#123;\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) &#123;\n        ListNode* dummyHead &#x3D; new ListNode(0);\n        dummyHead-&gt;next &#x3D; head;\n        ListNode* slow &#x3D; dummyHead;\n        ListNode* fast &#x3D; dummyHead;\n        while(n-- &amp;&amp; fast !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next;\n        &#125;\n        fast &#x3D; fast-&gt;next; &#x2F;&#x2F; fast再提前走一步，因为需要让slow指向删除节点的上一个节点\n        while (fast !&#x3D; NULL) &#123;\n            fast &#x3D; fast-&gt;next;\n            slow &#x3D; slow-&gt;next;\n        &#125;\n        slow-&gt;next &#x3D; slow-&gt;next-&gt;next;\n        return dummyHead-&gt;next;\n    &#125;\n&#125;;\n\n\n(2)有序数组性质Leetcode 88 合并两个有序数组\n\n\n\n\n\n\n\n\n给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。\n请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。\n注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。\n输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3\n输出：[1,2,2,3,5,6]\n\n\n双指针：分别用指针p1、p2遍历数组nums1和nums2，每次将两者中较大的数据放入临时数组中。\n\n逆向双指针：从头插入的情况容易覆盖原数组的数据，所以需要临时变量来储存排列后的数据；但由于nums1后半部分数据为空，可以让指针从后向前遍历，每次把两者中的较大放在数组的后面。\n![证明](C:\\Users\\Berton\\Pictures\\Camera Roll\\image-20211017192758089.png)\n\n\nclass Solution &#123;\npublic:\n    void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123;\n        int p1 &#x3D; m - 1, p2 &#x3D; n - 1;\n        int tail &#x3D; m + n - 1;\n        int cur;\n        while (p1 &gt;&#x3D; 0 || p2 &gt;&#x3D; 0) &#123;\n            if (p1 &#x3D;&#x3D; -1) &#123;\n                cur &#x3D; nums2[p2--];\n            &#125; else if (p2 &#x3D;&#x3D; -1) &#123;\n                cur &#x3D; nums1[p1--];\n            &#125; else if (nums1[p1] &gt; nums2[p2]) &#123;\n                cur &#x3D; nums1[p1--];\n            &#125; else &#123;\n                cur &#x3D; nums2[p2--];\n            &#125;\n            nums1[tail--] &#x3D; cur;\n        &#125;\n    &#125;\n&#125;;\n\n\nLeetcode 977 有序数组的平方\n\n\n\n\n\n\n\n\n给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。\n 输入：nums &#x3D; [-4,-1,0,3,10]\n输出：[0,1,9,16,100]\n解释：平方后，数组变为 [16,1,0,9,100]\n排序后，数组变为 [0,1,9,16,100]\n\n\n原数组有序，只不过可能有负数平方后成为最大数，即&#x3D;&#x3D;最大数只可能在数组两端&#x3D;&#x3D;。可以用前后两个指针进行遍历，两者中的较大数放在数组的最后面。\n\n\n(3)原地替换（从后端空位开始填充）剑指 Offer 05. 替换空格\n\n\n\n\n\n\n\n\n请实现一个函数，把字符串 s 中的每个空格替换成”%20”。\n\n先将字符串**&#x3D;&#x3D;扩容&#x3D;&#x3D;成替换空格后的长度，然后&#x3D;&#x3D;利用双指针从后向前填充&#x3D;&#x3D;**。如果从前向后填充就是O(n^2)的算法了，因为每次添加元素都要将之后的所有元素向后移动。\n\nclass Solution &#123;\npublic:\n    string replaceSpace(string s) &#123;\n        int count &#x3D; 0; &#x2F;&#x2F; 统计空格的个数\n        int sOldSize &#x3D; s.size();\n        for (int i &#x3D; 0; i &lt; s.size(); i++) &#123;\n            if (s[i] &#x3D;&#x3D; &#39; &#39;) \n                count++;\n        &#125;\n        &#x2F;&#x2F; 扩充字符串s的大小，也就是每个空格替换成&quot;%20&quot;之后的大小\n        s.resize(s.size() + count * 2);\n        int sNewSize &#x3D; s.size();\n        &#x2F;&#x2F; 从后先前将空格替换为&quot;%20&quot;\n        for (int i &#x3D; sNewSize - 1, j &#x3D; sOldSize - 1; j &lt; i; i--, j--) &#123;\n            if (s[j] !&#x3D; &#39; &#39;) &#123;\n                s[i] &#x3D; s[j];\n            &#125; else &#123;\n                s[i] &#x3D; &#39;0&#39;;\n                s[i - 1] &#x3D; &#39;2&#39;;\n                s[i - 2] &#x3D; &#39;%&#39;;\n                i -&#x3D; 2;\n            &#125;\n        &#125;\n        return s;\n    &#125;\n&#125;;\n\n\n(4)滑动窗口（尺取法&#x2F;单调队列）Leetcode 209 长度最小的子数组\n\n\n\n\n\n\n\n\n给定一个含有 n 个正整数的数组和一个正整数 target 。\n找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。\n输入：target &#x3D; 7, nums &#x3D; [2,3,1,2,4,3]\n输出：2\n解释：子数组 [4,3] 是该条件下的长度最小的子数组。\n\n\n算法思想1、在序列中使用双指针中的左右指针技巧，初始化 start &#x3D; end &#x3D; 0，把索引闭区间 [start, end] 称为一个窗口。2、先不断地增加 end 指针扩大窗口 [start, end]，直到窗口中的序列符合要求。3、此时，停止增加 end，转而不断增加 start 指针缩小窗口 [start, end]，直到窗口中的序列不再符合要求。同时，每次增加 start 前，都要更新一轮结果。4、重复第 2 和第 3 步，直到 end 到达序列的尽头。\n\nclass Solution &#123;\npublic:\n    int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123;\n        int n &#x3D; nums.size();\n        if (n &#x3D;&#x3D; 0) &#123;\n            return 0;\n        &#125;\n        int ans &#x3D; INT_MAX;\n        int start &#x3D; 0, end &#x3D; 0;\n        int sum &#x3D; 0;\n        while (end &lt; n) &#123;  &#x2F;&#x2F;数组最后一个下标是n-1\n            sum +&#x3D; nums[end];\n            while (sum &gt;&#x3D; s) &#123;\n                ans &#x3D; min(ans, end - start + 1);\n                sum -&#x3D; nums[start++];\n            &#125;\n            end++;\n        &#125;\n        return ans &#x3D;&#x3D; INT_MAX ? 0 : ans;\n    &#125;\n&#125;;\n\n\n满足条件的连续子序列\n\n\n\n\n\n\n\n\n给你长度为 n 的数组 a 和一个正整数 k ，问你 a 有多少个和大于等于 k 的连续子序列。\n\n&#x3D;&#x3D;如果连续子序列[l , r]的和已经&gt;&#x3D;k，那么从l到r+1,r+2……的和都大于k，这样的子序列一共有n-r+1。&#x3D;&#x3D;那么只要从0—n-1遍历所有的l，对于一个给定的l，&#x3D;&#x3D;找出最小的r&#x3D;&#x3D;使得∑[l,r]&gt;&#x3D;k。\n对于给定的l，可以用类似&#x3D;&#x3D;滑动窗口&#x3D;&#x3D;的方式快速求出最小的r：若前一个l已经找到满足条件的最小的r，则只需要从前一次的和中减去a[l],得到的就是l+1—r的和。如果这个和大于k，那么r仍然最小的；若和小于k，则r向右移动，直到和重新大于k。\n\n\n#include &lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nll a[100010];\nint main() &#123;\n    int n;\n    ll k;\n    cin &gt;&gt; n &gt;&gt; k; &#x2F;&#x2F; 数组长度为n，要大于等于的数是k\n    for (int i &#x3D; 0; i &lt; n; i++) &#123;\n        scanf(&quot;%lld&quot;, &amp;a[i]);\n    &#125;\n    ll ans &#x3D; 0; &#x2F;&#x2F; 答案\n    ll left &#x3D; 0, right &#x3D; 0;   &#x2F;&#x2F; l和r初始值都是0\n    ll sum &#x3D; a[0];            &#x2F;&#x2F; sum代表[left, right]的和\n    while (right &lt; n) &#123;       &#x2F;&#x2F; 右边r还未移出数组时\n        if (sum &gt;&#x3D; k) &#123;       &#x2F;&#x2F; sum[l, r] &gt;&#x3D; k\n            ans +&#x3D; n - right; \n&#x2F;&#x2F; 此时就是在对应l下，最小的满足题意的r。sum[l, r] &gt;&#x3D; k, sum[l, r + 1] &gt;&#x3D; k ...             \t sum[l, n - 1] &gt;&#x3D; k（输入的时候数组存储下标是0~n-1，比题解中1~n小1）\n            sum -&#x3D; a[left++]; &#x2F;&#x2F; 枚举下一个l（l++），相应地sum也要减去不在范围内的a[l]\n        &#125; else &#123;              &#x2F;&#x2F; sum[l, r] &lt; k，还没找到最小的r\n            sum +&#x3D; a[++right]; &#x2F;&#x2F; r右移并累加入总和\n        &#125;\n    &#125;\n    cout &lt;&lt; ans &lt;&lt; endl;\n    return 0;\n\n\n\n\n(5)翻转问题Leetcode 344 反转字符串\n\n\n\n\n\n\n\n\n编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 s 的形式给出。\n不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。\n\n\nclass Solution &#123;\npublic:\n    void reverseString(vector&lt;char&gt;&amp; s) &#123;\n        for (int i &#x3D; 0,j &#x3D; s.size() - 1;i &lt; s.size()&#x2F;2;i++,j--) &#123;\n            swap(s[i],s[j]);\n        &#125;\n    &#125;\n&#125;;\n\n\n(6)指针相遇链表相交\n\n\n\n\n\n\n\n\n给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。\n\n从头节点headA和headB开始分别遍历链表，**&#x3D;&#x3D;如果遍历完当前链表，则将指针指向另外一个链表的头部继续遍历&#x3D;&#x3D;**；若链表相交，在遍历完两个链表时指针一定相遇。若两个结点不相交，则将会同时到达NULL。\n\n\n\nclass Solution &#123;\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123;\n        ListNode* a &#x3D; headA;\n        ListNode* b &#x3D; headB;\n        while (a !&#x3D; b)\n        &#123;\n            a &#x3D; a !&#x3D; nullptr ? a-&gt;next : headB;\n            b &#x3D; b !&#x3D; nullptr ? b-&gt;next : headA;\n        &#125;\n        return a;\n    &#125;\n&#125;;\n\n\n(7)排序和双指针优化双重遍历Leetcode 15 三数之和\n\n\n\n\n\n\n\n\n给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。\n\n将数组非降序排序，然后对 i 进行遍历，同时定义left &#x3D; i+1，right &#x3D; n-1，相当于把三数之和转换成了两数之和——nums[left]+nums[right]&#x3D;&#x3D;-nums[i]；\n如果 nums[left] + nums[right] &gt; -nums[i] ，说明此时两数之和过大，right需要左移，反之left右移。\n\n\nclass Solution &#123;\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;\n        vector&lt;vector&lt;int&gt;&gt; result;\n        sort(nums.begin(), nums.end());\n        for (int i &#x3D; 0; i &lt; nums.size(); i++) &#123;\n            &#x2F;&#x2F; 非降序排序后如果第一个元素大于零，那么不存在等于0的三元和\n            if (nums[i] &gt; 0) &#123;\n                return result;\n            &#125;\n            &#x2F;&#x2F; 错误去重方法，将会漏掉-1,-1,2 这种情况\n            &#x2F;*\n            if (nums[i] &#x3D;&#x3D; nums[i + 1]) &#123;\n                continue;\n            &#125;\n            *&#x2F;\n            &#x2F;&#x2F; 正确去重方法\n            if (i &gt; 0 &amp;&amp; nums[i] &#x3D;&#x3D; nums[i - 1]) &#123;\n                continue;\n            &#125;\n            int left &#x3D; i + 1;\n            int right &#x3D; nums.size() - 1;\n            while (right &gt; left) &#123;\n                &#x2F;&#x2F; 去重复逻辑如果放在这里，样例[0,0,0]会因为right&lt;&#x3D;left，漏掉[0,0,0]的答案\n                &#x2F;*\n                while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n                *&#x2F;\n                if (nums[i] + nums[left] + nums[right] &gt; 0) &#123;\n                    right--;\n                &#125; else if (nums[i] + nums[left] + nums[right] &lt; 0) &#123;\n                    left++;\n                &#125; else &#123;\n                    result.push_back(&#123;nums[i], nums[left], nums[right]&#125;);\n                    &#x2F;&#x2F; 去重逻辑应该放在找到一个三元组之后\n                    while (right &gt; left &amp;&amp; nums[right] &#x3D;&#x3D; nums[right - 1]) right--;\n                    while (right &gt; left &amp;&amp; nums[left] &#x3D;&#x3D; nums[left + 1]) left++;\n                    &#x2F;&#x2F; 找到答案时，双指针同时收缩\n                    right--;\n                    left++;\n                &#125;\n            &#125;\n\n        &#125;\n        return result;\n    &#125;\n&#125;;\n\n\nLeetcode 18 四数之和\n\n\n\n\n\n\n\n\n给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）\n\n四数之和的双指针解法是两层for循环 nums[k] + nums[i] 为确定值，依然是循环内有 left 和 right 下表作为双指针，找出 nums[left] + nums[right] &#x3D;&#x3D; target - nums[k] - nums[i] 的情况，四数之和的时间复杂度是O(n^3) 。双指针法可以将时间复杂度相对于暴力枚举降一个数量级。\n\n\n在序列中寻找不相等数字的最大距离\n设置头尾指针，即从最大长度开始遍历，在不断缩小长度的过程中最先找到的不相等数字距离最大。\n\n\n","slug":"算法3-双指针法","date":"2022-10-01T09:46:35.000Z","categories_index":"算法","tags_index":"双指针法","author_index":"MiF"},{"id":"23b460b1d81bc84883e4eda5dcad0a53","title":"算法2-位运算","content":"(1)异或(^)Leetcode 17.04 消失的数\n\n\n\n\n\n\n\n\n数组nums包含从0到n的所有整数，但其中缺了一个。请编写代码找出那个缺失的整数。你有办法在O(n)时间内完成吗？\n**1.**异或运算的特性：计算机中两个数（补码）按位进行异或；\n​\t\t\t\t\t\t\t\t两个相同的数异或等于0；\n​\t\t\t\t\t\t\t\t任何数与0异或结果还是那个数。\n&#x3D;&#x3D;&gt; a^b^c^c^b=a，两对相同的数异或之后等于0，再与只有单个的数异或还等于那个数。\n**2.**ans的初始值设为0，所以for循环只需要1 - n。对于样例[3，0，1]，相当于0^1^3^2^0^3^1=2。\nint missingNumber(vector&lt;int&gt;&amp; nums) &#123;\n    int n&#x3D;nums.size(),ans&#x3D;0;\n    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;\n        ans^&#x3D;i;\n        ans^&#x3D;nums[i-1];\n    &#125;\n    return ans;\n&#125;\n\n改编1（寻找两个唯一的数）\n\n\n\n\n\n\n\n\n现在把难度升级一下，若数组里存在两个唯一的数，该怎么把它找出来呢？按照之前的方法，只能得到 n1^n2，拿不到独立的数。\nn1跟n2是不同的数，那么在它们二进制的表示上，至少有一位是不一样的，那我们可以根据这一位上是1还是0把数组里的数分成两拨，这两个数肯定就在各自的分组里，然后相同的数也肯定在同一个分组里，再让这两拨数做异或运算，最后各自剩下来的就是我们要的两个数。\npublic static int[] findSingleNumbers(int[] nums) &#123;\n    int n1xn2 &#x3D; 0;\n    for (int num : nums) &#123;\n        n1xn2 ^&#x3D; num;\n    &#125;\n    &#x2F;&#x2F;n1xn2为两个唯一数异或的结果\n    int rightmostSetBit &#x3D; 1;\n    &#x2F;&#x2F;通过与运算和移位运算从右往左找到第一个不同的位进行分组\n    while ((rightmostSetBit &amp; n1xn2) &#x3D;&#x3D; 0) &#123;\n        rightmostSetBit &#x3D; rightmostSetBit &lt;&lt; 1;\n    &#125;\n    int num1 &#x3D; 0, num2 &#x3D; 0;\n    for (int num : nums) &#123;\n        if ((num &amp; rightmostSetBit) !&#x3D; 0)\n            num1 ^&#x3D; num;\n        else\n            num2 ^&#x3D; num;\n    &#125;\n    return new int[]&#123;num1, num2&#125;;\n&#125;\n\n改编2（寻找一个重复的数）\n\n\n\n\n\n\n\n\n给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。\n我们发现在查找“奇数个”的数据的时候，异或运算用起来还是非常方便的。因此不妨将数字1-n和数组nums异或，结果只有重复两次的数字异或了三次（奇数次），剩下的就是重复的数字。\n其他应用\n交换两个数\n优点是少了一个临时变量，执行效率也比较高。\n\n\nvoid swap(ref int a, ref int b)&#123;\n    a ^&#x3D; b;\n    b ^&#x3D; a;\n    a ^&#x3D; b;\n&#125;\n\n\n备份硬盘\n有 N + 1 块相同容量的硬盘，其中 N 块用来存储数据，如果利用多余的 1 块硬盘来存储 N 块硬盘的数据备份，假设硬盘最多同时只会损坏 1 块。多余的 1 块硬盘存储 N 块硬盘异或的结果，那么当其中 1 块硬盘损坏的时候，只需要把其他好的硬盘数据再异或一遍，即可得到损坏的硬盘的数据了。\n\n加密数据\n加密：明文^密钥&#x3D;密文 ，解密：密文^密钥&#x3D;明文。\n\n\n(2)与(&amp;)Leetcode 2154 将找到的值乘以 2\n判断一个数是否为2的幂次\n如果一个数是2的幂次，那么它的二进制中有且仅有一位是 1，那么&#x3D;&#x3D;k &amp; (k - 1)&#x3D;&#x3D;的结果是 0。以k &#x3D; 16为例，其二进制为 1 0000，k - 1的二进制为 0 1111， 1 0000 &amp; 0 1111 &#x3D; 0 0000。\n所以要判断一个数是不是2的幂次，只要将这个数和其减一相与，若结果为0则是，反之则否。\n\n\n","slug":"算法2-位运算","date":"2022-10-01T09:46:09.000Z","categories_index":"算法","tags_index":"位运算","author_index":"MiF"},{"id":"7dc4f02b5b9064910d8a6525e70f6010","title":"算法1-数学基础","content":"(1)负数的补码形式\n\n\n\n\n\n\n\n\n计算机中通常用&#x3D;&#x3D;补码&#x3D;&#x3D;进行数值运算（负数用补码表示）。\n\n引入”模”的概念：\n\n\n\n\n\n\n\n\n\n\n模是一个计量系统的计数范围。模是一个溢出的量，只能表示模的余数。有模的计量器可化减法为加法。如时钟的模为12，计量范围可看作0-11，那么从10点拨到6点，可倒拨4h或顺拨8h（即+4和-8的效果相同）。\n\n进制运算有模的原理是&#x3D;&#x3D;高位丢失&#x3D;&#x3D;；\n如四位二进制1111加1后为10000，最高位溢出后为0000；不难得到它的模为2^4。\n那么$0100-0010&#x3D;0100+(2^4-0010)&#x3D;0100+(1111-0010)+1$\n由上可知，负数求补码的过程是 &#x3D;&#x3D;取绝对值-&gt;逐位取反-&gt;加1&#x3D;&#x3D;。相同的，由补码转换为原码的方式为 -1-&gt;逐位取反-&gt;加负号。\n\n\n(2)大数运算（高精度算法）\n\n\n\n\n\n\n\n\n大数指超过计算机表示范围的数值。通常用&#x3D;&#x3D;数组&#x3D;&#x3D;进行表示。\n高精加低精Leetcode 989 数组形式的整数加法\n\n\n\n\n\n\n\n\n\n对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X &#x3D; 1231，那么其数组形式为 [1,2,3,1]。给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。\n输入：A &#x3D; [1,2,0,0], K &#x3D; 34\n输出：[1,2,3,4]\n解释：1200 + 34 &#x3D; 1234\n\nvector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123;\n    vector&lt;int&gt; ans;\n    int n &#x3D; num.size();\n    for (int i &#x3D; n - 1; i &gt;&#x3D; 0 || k &gt; 0; --i, k &#x2F;&#x3D; 10) &#123;\n        if (i &gt;&#x3D; 0) &#123;\n            k +&#x3D; num[i];&#x2F;&#x2F;将k与num最后一位相加，依次向前进位\n        &#125;\n        ans.push_back(k % 10);\n    &#125;\n    reverse(ans.begin(), ans.end());&#x2F;&#x2F;逆序\n    return ans;\n&#125;\n\n压位高精\n普通的高精度算法使用一个数组或字符串元素存储一个十进制数位。为了节省时间和空间，我们使用位压**&#x3D;&#x3D;在每一个int类型的数组中存储4位数字&#x3D;&#x3D;**（5位在乘法中可能会溢出）。\n\n\n(3)判断素数int isprime(int n)&#123;\n    if(n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 0) &#x2F;&#x2F;0和1不是素数，需要分类讨论\n        return 0;\n    for(int i &#x3D; 2; i &lt;&#x3D; sqrt(n); ++i)\n        if(n % i &#x3D;&#x3D; 0)\n            return 0;\n    return 1;\n&#125;\n\n\n(4)最大公约数与最小公倍数\n辗转相除求最大公约数\n\n\n\n\n\n\n\n\n\n\n欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。计算公式 $gcd(a,b) &#x3D; gcd(b,a\\ mod\\ b)$，即两个整数的最大公约数等于其中较小的那个数和两数相除余数的最大公约数。\n&#x2F;&#x2F;循环形式\nint Gcd(int a, int b)&#123;\n    while(r &gt; 0)&#123;\n        r &#x3D; a % b;\n        a &#x3D; b;\n        b &#x3D; r;\n    &#125;\n    return a;\n&#125;\n&#x2F;&#x2F;递归形式\nint Gcd(int a, int b)&#123;\n    return b &#x3D;&#x3D; 0 ? a : gcd(b, a % b);\n&#125;\n\n\n分解质因数求最小公倍数\n\n&#x2F;&#x2F; x * y &#x3D; lcm * gcd\nint Lcm(int x, int y)&#123;\n    int g &#x3D; Gcd(x, y);\n    return fabs(x &#x2F; g * y);   &#x2F;&#x2F; 先乘再除中间量可能会溢出\n&#125;\n\n\n(5)负进制转换\n负数的除法和取余运算：1.正数和负数的除法运算（&#x2F;）都是向0取整的，int类型的除法是直接去掉小数部分；\n2.负数取余先通过取模（绝对值）计算，符号由&#x3D;&#x3D;被除数&#x3D;&#x3D;决定。\n\n\n洛谷 P1017 [NOIP2000 提高组] 进制转换\n\n\n\n\n\n\n\n\n\n设计一个程序,读入一个十进制数x和一个负进制数n的基数, 并将此十进制数转换为此负进制下的数。\n\n如果是以 R 或 -R 为基数,则需要用到的数码为 0,1,……,R−1。\n例如当 R&#x3D;-7 时,所需用到的数码是 0,1,2,3,4,5,6；这与其是 R 或 -R 无关。\n\n负进制与正进制大体相同，只不过有时取余的结果会是负数，那么就需要像借位一样，向前借-1，余数就可以转化为正数（因为进制数一定大于余数）。\n\n\nvoid NegativeBase(int x, int n)&#123;\n    if(x &#x3D;&#x3D; 0) return;    &#x2F;&#x2F;递归结束条件\n    int remainder;\n    remainder &#x3D; x % n;\n    if (remainder &gt;&#x3D; 0)\n    \tx &#x2F;&#x3D; n;\n    else&#123;\n    \tremainder -&#x3D; n;\n    \tx &#x3D; x &#x2F; n + 1;\n\t&#125;\n    &#x2F;&#x2F;由于输出的是字符类型，需要将remainder转化为相应的ascii值\n    remainder &#x3D; remainder &gt;&#x3D; 10? (remainder-10) + &#39;A&#39;: remainder + &#39;0&#39;;\n    NegativeBase(x, n);\n    &#x2F;&#x2F;函数的递归调用在栈中实现，利用栈的后进先出特点，进行逆序输出，因此输出语句写在递归的后面。\n    printf(&quot;%c&quot;,remainder);\n    return;\n&#125;\n\n\n(6)模运算取模运算的性质：\n\n加减乘都适用：(a + b) % p &#x3D; (a % p + b % p) % p\n多次取模等价于一次取模：(a % c) %c &#x3D; a % c\n\n\n\n\n\n\n\n\n\n\n如果环的模为 m 且元素从 0 开始，那么从 x 开始循环右移 k 位的表达式为 $(x+k)\\ mod\\ m$；如果元素从 1 开始则为$(x-1+k)\\mod\\ m+1$ 。大写字母构成的环可表达为$(x-‘A’+k) \\ mod \\ 26 + 65$ ，其中 x-‘A’ 可以将环构造成元素从 0 开始的环。\n\n(7)约瑟夫环Leetcode 剑指 Offer 62. 圆圈中最后剩下的数字\n\n\n\n\n\n\n\n\n\n0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。\n返回的答案应该是&#x3D;&#x3D;剩下的数字在原序列的下标&#x3D;&#x3D;，而问题的关键在于找到&#x3D;&#x3D;每次删除后形成的新序列索引与原序列下标之间的数学关系。&#x3D;&#x3D;\n\n\n\n&#x2F;&#x2F;递归\nint f(int n, int m) &#123;\n    if (n &#x3D;&#x3D; 1) &#123;\n        return 0;\n    &#125;\n    int x &#x3D; f(n - 1, m);\n    return (m + x) % n;\n&#125;\nint lastRemaining(int n, int m) &#123;\n    return f(n, m);\n&#125;\n\n&#x2F;&#x2F;迭代\nint lastRemaining(int n, int m) &#123;\n    int f &#x3D; 0;\n    for (int i &#x3D; 2; i !&#x3D; n + 1; ++i) &#123;\n        f &#x3D; (m + f) % i; \n    &#125;\n    return f;\n&#125;\n\n(8)快速幂\n\n\n\n\n\n\n\n\n快速幂就是快速算底数的n次幂。其时间复杂度为 O(log₂N)， 与朴素的O(N)相比效率有了极大的提高。\n\n快速幂的递归方程\n\n\n\nlong long binpow(long long a, long long b) &#123;\n    if (b &#x3D;&#x3D; 0) return 1;\n    long long res &#x3D; binpow(a, b &#x2F; 2); \n    if (b % 2)\n        return res * res * a;  &#x2F;&#x2F; 相当于 binpow(a, n-1) * a\n    else\n        return res * res;\n&#125;\n\n\n采用二进制取幂的方法\n\n通过连续的自乘运算，求出a的$2^k$次幂的序列，将对应二进制位为 1 的整系数幂相乘。\n如$3^{13} &#x3D; 3^{(1101)_2} &#x3D; 3^8 \\cdot 3^4 \\cdot 3^1$\n\n\nlong long binpow(long long a, long long b) &#123;\n    long long res &#x3D; 1;\n    while (b &gt; 0) &#123;\n        if (b &amp; 1) res &#x3D; res * a;\n        a &#x3D; a * a;\n        b &gt;&gt;&#x3D; 1;\n    &#125;\n    return res;\n&#125;\n\n\n模意义下取幂\n\n\n\n\n\n\n\n\n\n\n计算$a^b\\ mod\\ m$。\n模的运算不会干涉乘法运算，因此我们只需要在计算的过程中取模即可。\nlong long binpow(long long a, long long b, long long m) &#123;\n  a %&#x3D; m;\n  long long res &#x3D; 1;\n  while (b &gt; 0) &#123;\n    if (b &amp; 1) res &#x3D; res * a % m;\n    a &#x3D; a * a % m;\n    b &gt;&gt;&#x3D; 1;\n  &#125;\n  return res;\n&#125;\n\n","slug":"算法1-数学基础","date":"2022-10-01T09:45:17.000Z","categories_index":"算法","tags_index":"数学基础","author_index":"MiF"}]