[{"id":"42f387978a941c90eb0f7971a3f9fdef","title":"Python_tricks","content":"Swaping valuesa, b = 10, 5\na, b = b, a\n\n####Create a single string from all the elements in list\na = [\"Python\", \"is\", \"awesome\"]\nprint(\" \".join(a))\n\nFind The Most Frequent Value In A Lista = [1, 2, 3, 1, 2, 3, 2, 2, 4, 5, 1]\nprint(max(set(a), key = a.count))\n\"\"\" using Counter from collections \"\"\"\nfrom collections import Counter\ncnt = Counter(a)\n\"\"\"output the three most frequent elements\"\"\"\nprint(cnt.most_common(3))\n\nCounter applies to hashable objects, each Counter object is a dictionary that maps an element to its frequency. Such as cnt[2] = 4.\nChecking if two words are anagramsfrom collections import Counter\nCounter(str1) == Counter(str2)\n\"\"\"if str1 = 'abc' and str2 = 'bca', then return true, because they have the same elements\"\"\"\n\nReverse a String\"\"\"using slice step param. slice(start, end, step)\"\"\"\nstr = 'abcdefghijk'\nprint(str[::-1])\n\"\"\"iterating over string contents in reverse\"\"\"\nfor char in reverse(str):\n    print(char)\n\"\"\"reversing an integer through type conversation and slicing\"\"\"\nnum = 123456789\nprint(int(str(num)[::-1]))\n\n","slug":"Python_tricks","date":"2022-10-06T04:19:43.000Z","categories_index":"语言特性","tags_index":"Python","author_index":"MiF"},{"id":"40f7427d94a97a10aada378041f90424","title":"A5-数据结构","content":"\n\n\n\n\n\n为什么选择利用数组模拟数据结构\n-链表需要频繁使用new/malloc动态申请结点空间，会占用大量的时间和空间。\n-利用数组模拟数据结构相当于在内存使用前先申请分配一定大小的空间作为备用，并利用数组下标代替内存地址实现结点的链式储存。\n\n\n静态链表单链表#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\n// head 表示头结点的下标 ==&gt; 头指针\n// e[i] 表示结点 i 的值 ==&gt; data域\n// ne[i] 表示结点 i 后继结点的下标 ==&gt; 指针域\n// idx 标记在数组内存中当前使用到的位置\nint head, e[N], ne[N], idx;\n// 初始化\nvoid init() {\n\thead = -1;\n    idx = 0;\n}\nvoid push_front(int x) {  // 头插法\n\te[idx] = x;\n    ne[idx] = head;\n    head = idx++;\n}\nvoid pop_front() {\n    head = ne[head];\n}\n\n双向链表#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\nint e[N], l[N], r[N], idx;\nvoid init() {\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n\n栈int stack[N], top = 0; // 栈底为1\nvoid push(int x) {\n    stack[++ top] = x;\n}\nvoid pop() {\n    if(!StackEmpty()) -- top;\n}\nvoid StackEmpty() {\n    return top == 0;\n}\n\n队列普通队列int queue[N], front = 0, rear = -1; // 队头为1\nvoid push_back(int x) {\n    queue[++ rear] = x;\n}\nvoid pop_front() {\n    if(!QueueEmpty()) ++ front;\n}\nvoid QueueEmpty() {\n\treturn front &gt; rear;\n}\n\n循环队列int sqQueue[N], front = rear = 0;\nvoid push_back(int x) {\n    queue[rear ++] = x;\n    if(rear == N) rear = 0;\n}\nvoid pop_front() {\n    if(!QueueEmpty()) {\n    \t++ front;\n        if(front == N) front = 0;\n    }\n}\nvoid QueueEmpty() {\n\treturn front == rear;\n}\n\n单调栈适用于找出每个数左边离它最近的比它大/小的数。\nint stack[N], top = 0; // stack 储存下标\nfor (int i = 0; i &lt; N; ++i) {\n    // 小于 i 的所有元素出栈\n\twhile(top &amp;&amp; stack[top] &gt; arr[i]) -- top;\n    stack[++ top] = i;\n}\n\n单调队列适用于求滑动窗口中的最大值/最小值。\nint queue[N], front = 0, rear = -1;\nfor (int i = 0; i &lt; N; ++i) {\n\twhile(front &lt;= rear &amp;&amp; i - front &gt; k) ++ front; // 超出窗口范围\n    while(front &lt;= reae &amp;&amp; queue[rear] &lt;= arr[i]) -- rear; // 保持队列元素单调递减\n    queue[++ rear] = i;\n}\n\nKMP#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010, M = 1000010;\nchar s[M], p[N];\nint ne[N];\n// 字符串s，模式串p，len(s)=n，len(p)=m，数组下标从1开始\nint n, m;\nint main() {\n    cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1;\n    // 求模式串的 Next 数组: 相当于两个模式串间的匹配\n    for (int i = 2, j = 0; i &lt;= n; ++ i) {\n        while(j &amp;&amp; p[i] != p[j + 1]) j = ne[j];\n        if(p[i] == p[j + 1]) ++ j;\n        ne[i] = j;\n    }\n    // 匹配: i遍历字符串s, j标记模式串当前匹配到的位置\n    for(int i = 1, j = 0; i &lt;= m; ++ i) {\n        while(j &amp;&amp; s[i] != p[j + 1]) j = ne[j]; // 递归匹配最大前后缀，j = 0 时应退出循环\n        if(s[i] == p[j + 1]) ++ j;\n        if(j == n) {\n            cout &lt;&lt; i - n + 1;\n            j = ne[j]; // 寻找下一匹配项\n        }\n    }\n    return 0;\n}\n\nTrie树树又称为前缀树，原理是利用字符串的公共前缀提高搜索效率，但由于每个结点仅存储一个字符，是一种利用空间换时间的算法。\n// 开辟N个结点的内存池，每个结点有26个可用子结点，利用idx进行链接\n// cnt[i]统计以第i个结点为末尾的字符串频数\nint node[N][26], cnt[N], idx;\nvoid insert(char *str) {\n\tint p = 0; // 根结点为node[0]\n    for(int i = 0; str[i]; ++ i) { // 字符串数组以'\\0'结尾\n        int u = str[i] - 'a';\n        if(!node[p][u]) node[p][u] = ++ idx;\n        p = node[p][u];\n    }\n    ++ cnt[p];\n}\nint query(char *str) {\n    int p = 0;\n    for(int i = 0; str[i]; ++ i) {\n        int u = str[i] - 'a';\n        if(!node[p][u]) return 0;\n        p = node[p][u];\n    }\n    return cnt[p];\n}\n\n并查集主要支持以下两种操作：\n\n合并两个不相交的集合\n查询两个元素是否在同一集合中\n\nint f[N]; // 储存结点的父结点\nint init(int n) {\n    for(int i = 0; i &lt; n; ++ i)\n        f[i] = i;\n}\nint find(int x) { // 寻找结点x的根结点\n    return f[x] == x? x: (f[x] = find(f[x])); // 路径压缩，每次查询时将路径中的结点指向根结点\n}\nvoid merge(int i, int j) {\n    f[find(i)] = find(j); // 将结点i的根结点指向结点j\n}\n// 判断结点i和结点j是否在同一集合内\nfind(i) == find(j)\n\n堆（优先队列）堆分为最大堆和最小堆；最大堆中父节点的值比每一个子结点都大，最小堆反之；堆总是一棵完全二叉树。\nvoid down(int u) {\n    int t = u;\n    // 结点 u 是父结点，u * 2 和 u * 2 + 1 分别是它的左右孩子，t标记3个结点中的最小值\n    if(u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;\n    if(u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;\n    // 将父结点与值最小的结点交换\n    if(t != u) {\n\t\tnode_swap(t, u);\n        down(t); // 递归地让该结点下沉\n    }\n}\nvoid up(int u) {\n    // 当前结点的值大于父结点就up\n    while(u &gt;&gt; 1 &amp;&amp; h[u] &lt; h[u &gt;&gt; 1]) {\n        node_swap(u, u &gt;&gt; 1);\n        u &gt;&gt;= 1;\n    }\n}\nvoid build_heap() {\n    for(int i = n &gt;&gt; 1; i; -- i) down(i);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"A5-数据结构","date":"2022-10-06T04:19:24.384Z","categories_index":"数据结构","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"1021d88cce27c5945c95fc3401510b8b","title":"A4-前缀和&差分","content":"前缀和一维前缀和// 为处理边界, a 的下标从 1 开始： a[1...n], 初始化 s[0] = 0\n// 1. 额外开一个前缀和数组 s\nfor(int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i];\n// 2. 在原数组基础上构建前缀和\nfor(int i = 1; i &lt;= n; ++i) a[i] += a[i - 1];\n// 一维前缀和的主要应用就是求数列 a 在 [l, r] 区间内的和 s_lr\ns_lr = s[r] - s[l - 1];\n\n\n\n\n\n\n\nC++的默认初始化机制\n数值型全局变量和静态变量均会默认初始化为0，而函数体(包括main函数)中定义的局部变量未被初始化，它的值是不确定的。\n\n\n求数组  区间内的元素和，朴素的遍历求和法进行m次询问的时间复杂度为 ，而利用前缀和单次询问的时间复杂度为。\n二维前缀和\n// 二维数组 a 从 a[1][1] 开始\n// s[i][j] 代表右下角坐标为 (i, j), 且大小为 i*j 的子矩阵中所有元素的和\nfor(int i = 1; i &lt;= n; ++i) \n    for(int j = 1; j &lt;= m; ++j)\n        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];\n\n// 计算 以(x1, y1)和(x2, y2)为左上和右下角坐标的子矩阵的元素和 \nans = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\n\n\n模板题\n-99. 激光炸弹 - AcWing题库\n\n\n\n差分差分与前缀和是一对互逆运算，差分即构造差分序列使得原序列成为它的前缀和。利用差分性质可以将原序列上的“区间操作”(如区间+d)转化为差分序列上的“单点操作”，其时间复杂度从降低为。\n一维差分\n\n\n\n\n\n\n\n\n对于一个给定的数列 ，它的差分数列  定义为：\n\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\nint n, m;\n// a 为原数列, b 为 a 的差分数列\nint a[N], b[n];\n// 对数列 a 的 [l, r] 进行 +val 操作\n// ==&gt; 对差分数列 b 做 O(1) 的操作, b[l] + val, b[r + 1] - val\nvoid insert(int l, int r, int val) {\n    b[l] += val;\n    b[r + 1] -= val;\n}\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]);\n    // 构造差分数列\n    // 假设初始 a = [0,...,0], b = [0,...,0] \n    // 给 a[i] 赋值相当于对 [i, i] 进行 +a[i] 操作\n    for(int i = 1; i &lt;= n; ++i) insert(i, i, a[i]);\n    while(m--) {\n        int l, r, val;\n        scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;val);\n        insert(l, r, val);\n    }\n    // 在差分数列的基础上计算前缀和，即为操作后的数列\n    for(int i = 1; i &lt;= n; ++i) b[i] += b[i - 1];\n    for(int i = 1; i &lt;= n; ++i) printf(\"%d \", b[i]);\n}\n\n\n模板题\n-100. 增减序列 - AcWing题库\n-101. 最高的牛 - AcWing题库\n\n\n二维差分差分矩阵中一个元素的变动会影响右下角区域所有前缀和矩阵的元素。\n// 对 分别以(x1, y1)和(x2, y2)为左上和右下角坐标的子矩阵 +val\nb[x1][y1] += val;\nb[x2 + 1][y1] -= val;\nb[x1][y2 + 1] -= val;\nb[x2 + 1][y2 + 1] += val;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"A4-前缀和&差分","date":"2022-10-05T05:52:23.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"6940eb2ba483d3d0018fcb9e180da589","title":"A3-高精度","content":"高精度\n\n\n\n\n\nTIP\nc++ 中 unsigned long long 的数量级是 ，因此超过该数量级的数值处理就要涉及高精度运算。\n\n\n大数存储为方便处理进位，将大数在数组中逆序存储。\nint main() {\n    string s1, s2;\n    vector&lt;int&gt; num1, num2;\n    // 方便起见，首先利用字符串读取输入数据，再转化为数组\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    // Warning: 数字字符转换为数值时需要减'0'\n    for(int i = s1.size() - 1; i &gt;= 0; --i) num1.push_back(s1[i] - '0');\n    for(int i = s2.size() - 1; i &gt;= 0; --i) num2.push_back(s2[i] - '0');\n}\n\n高精度加法vector&lt;int&gt; add(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n    vector&lt;int&gt; res;\n    // Warning: 注意初始化进位\n    int t = 0;\n    for(int i = 0; i &lt; num1.size() || i &lt; num2.size(); ++i) {\n        if(i &lt; num1.size()) t += num1[i];\n        if(i &lt; num2.size()) t += num2[i];\n        res.push_back(t % 10);\n        t /= 10;\n    }\n    // 判断最高位是否存在进位\n    if(t) res.push_back(t); // ==&gt; res.push_back(1)\n    return res;\n}\n\n高精度减法// 判断 num1 是否 &gt;= num2\nbool cmp(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n\tif(num1.size() != num2.size()) return num1.size() &gt; num2.size();\n    for(int i = num1.size() - 1; i &gt;= 0; --i) \n        if(num1[i] != num2[i])\n            return num1[i] &gt; num2[i];\n    return true;\n}\n// 使用 sub 函数的条件是 num1 &gt;= num2\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n    vector&lt;int&gt; res;\n    int t = 0;\n    for(int i = 0; i &lt; num1.size(); ++i) {\n        t = num1[i] - t;\n        if(i &lt; num2.size()) t -= num2[i];\n        // (t + 10) % 10 综合了 (t &gt;= 0) -&gt; (t = t) 和 (t &lt; 0) -&gt; (t = t + 10) 两种情况\n        res.push_back((t + 10) % 10);\n        // 处理借位\n        t = t &lt; 0? 1 : 0;\n    }\n    // 删除前导0，但注意结果为0时需要保留最后一个0\n    while(res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();\n\treturn res;\n}\nint main() {\n    /* 大数存储部分略 */\n    if(!cmp(num1, num2)) {\n        res = sub(num2, num1);\n        printf(\"-\");\n    } else {\n        res = sub(num1, num2);\n    }\n    for(int i = res.size() - 1; i &gt;= 0; --i) printf(\"%d\", res[i]);\n}\n\n高精度乘低精度vector&lt;int&gt; mul(vector&lt;int&gt; &amp;num1, int num2) {\n    vector&lt;int&gt; res;\n\tint t = 0;\n    // 循环条件为 num1 的数位未完全遍历 或 t中存在进位\n    for(int i = 0; i &lt; num1.size() || t; ++i) {\n        if(i &lt; num1.size()) t += num1[i] * num2;\n        res.push_back(t % 10);\n        t /= 10;\n    }\n    return res;\n}\n\n高精度除低精度vector&lt;int&gt; div(vector&lt;int&gt; &amp;num1, int num2, int &amp;r) {\n    vector&lt;int&gt; res;\n    int r = 0;\n    for(int i = num1.size() - 1; i &gt;= 0; --i) {\n\t\tr = r * 10 + num1[i]; // 关键\n        res.push_back(r / num2);\n        r %= num2;\n    }\n    reverse(res.begin(), res.end());\n    while(res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();\n    return res;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"A3-高精度","date":"2022-10-01T09:46:35.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"7092e7a06827631ebc7687e38da9f572","title":"A2-二分","content":"整数二分\n\n\n\n\n\n二分问题的本质\n基于某个预设条件，可将区间划分为两个连续的状态区间(满足/不满足)，问题的答案就在区间的边界上。\n\n\n两种二分模板// 模板1：区间[l, r]被划分为[l, mid]和[mid + 1, r]\nint bin_search_1(int l, int r) {\n    while(l &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if(check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 模板2：区间[l, r]被划分成[l, mid - 1]和[mid, r]\nint bin_search_2(int l, int r) {\n    while(l &lt; r) {\n        // Warning:此处mid应取右，否则当l=r-1时左边界取左会陷入死循环\n\t\tint mid = l + r + 1 &gt;&gt; 1;\n        if(check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n模板的选择\n边界  和  怎么更新，取决于目标答案是 ans1 还是 ans2，当 mid 落在右区间时，mid 可能就是 ans2 ，那么在寻找 ans2 时右边界  应更新为 mid，反之在寻找 ans1 时右边界应更新为 mid - 1。确定题目的目标是 ans1 还是ans2 只需要判断答案是否满足预设条件。\n\n\n\n\n\n\n解题关键\n-确定区间的划分条件\n-确定区间边界的更新方式\n-根据更新方式确定mid的计算方式(取左还是取右)\n\n\n\n浮点数二分浮点数二分不需要考虑边界条件，只需要设定答案精度作为迭代停止的条件。\n","slug":"A2-二分","date":"2022-10-01T09:46:09.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"95cb927361df204c35cf3acbf99ad432","title":"A1-快速&归并排序","content":"快速排序基本思路1.确定pivot(基准值)，一般选择区间右端点；\n2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot；\n3.利用递归实现区间排序。\n双指针法实现区间划分左指针从左到右找到第一个不小于基准值的元素，右指针从右到左找到第一个不大于基准值的元素，如果左指针小于右指针，则交换两个指针对应的元素，直到左指针大于等于右指针时停止迭代。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e6 + 10;\nint n;\nint q[N];\nvoid quick_sort(int q[], int l, int r) {\n    if(l &gt;= r) return;\n    int pivot = q[l], i = l - 1, j = r + 1;\n    while(i &lt; j) {\n        // 找到第一个不小于基准值的元素\n        do ++i; while(q[i] &lt; pivot);\n        // 找到第一个不大于基准值的元素\n        do --j; while(q[j] &gt; pivot);\n        if(i &lt; j) swap(q[i], q[j]);\n    }\n    // j指向第一个区间的最后一个元素\n    // Warning: 使用j进行划分时,pivot不能取到区间右端点,算例[1, 2]会陷入死循环\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;q[i]);\n    quick_sort(q, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", q[i]);\n    return 0;\n}\n\n算法优化时间复杂度分析\n最好情况\n每次选取的pivot都能将数组平均划分为两部分，由于划分的过程为，递归深度为，所以总的运行时间为。\n\n最坏情况\n假设始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分只能将问题规模减少１，所以运行时间为。\n\n\n排序算法对数据的有序性敏感，其时间复杂度会退化为，典型如LeetCode 912 排序数组，测试集存在5w个2的算例，利用朴素的快排会TLE。\n两种改进方法快排的优化主要在于对pivot的选取，对于Choose-Left和Choose-Right，常见的改进方法主要有Random和Median-Of-Three。\nRandompivot = rand() % (l - r) + l\n\nMedian-Of-Threevoid swap_arr_elm(int q[], int elm1, int elm2) {\n    swap(q[elm1], q[elm2]);\n}\nint M3(int q[], int l, int r) {\n    //计算数组中间的元素的下标\n    int mid = (r + l) / 2;\n    //使用三数中值法选择枢轴\n    if (q[l] &gt; q[r])\n        swap_arr_elm(q, l, r);\n    if (q[mid] &gt; q[r])\n        swap_arr_elm(q, mid, r);\n    if (q[mid] &gt; q[l])\n        swap_arr_elm(q, mid, l);\n    //此时，arr[mid] &lt;= arr[l] &lt;= arr[r],low的位置上保存这三个位置中间的值\n    return q[l];\n}\n\n上述代码已通过LeetCode、洛谷及牛客等OJ平台的算例测试，可放心食用。\n另外，STL源码中的sort方法虽然主要基于快速排序，但对于小区间(临界元素个数为16)会改用insert_sort(插入排序)，且在递归层次过深时利用的是heap_sort(堆排序)。\n\n归并排序基本思路1.以中间点  作为分界点；\n2.调用递归函数 merge_sort 对  和  进行排序；\n3.对两个有序区间进行线性归并。\n双指针法实现线性归并维护两个指针  和  表示当前考虑到  里的第  个位置和  的第 j 个位置。保证每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后  即为有序的。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nint n;\nint m[N], tmp[N];\nvoid merge_sort(int m[], int l, int r) {\n    if(l &gt;= r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    merge_sort(m, l, mid);\n    merge_sort(m, mid + 1, r);\n    // 递归调用后，两个区间均有序\n    int k = 0, i = l, j = mid + 1;\n    // 利用双指针法每次将较小的数加入tmp数组\n    while(i &lt;= mid &amp;&amp; j &lt;= r)\n        tmp[k++] = m[i] &lt;= m[j]? m[i++]: m[j++];\n    // 如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入tmp数组中即可\n    while(i &lt;= mid) tmp[k++] = m[i++];\n    while(j &lt;= r) tmp[k++] = m[j++];\n    // 用有序的tmp数组替换原数组的[l, r]区间\n    for(int i = l, j = 0; i &lt;= r; ++i, ++j) m[i] = tmp[j];\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;m[i]);\n    merge_sort(m, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", m[i]);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n","slug":"A1-排序","date":"2022-10-01T09:45:17.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"}]