[{"id":"6940eb2ba483d3d0018fcb9e180da589","title":"A3-高精度","content":"","slug":"A3-高精度","date":"2022-10-01T09:46:35.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"6a49a2a8dbdf479f908b306e73b4a790","title":"A2-整数二分","content":"","slug":"A2-整数二分","date":"2022-10-01T09:46:09.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"95cb927361df204c35cf3acbf99ad432","title":"A1-快速&归并排序","content":"快速排序基本思路1.确定pivot(基准值)，一般选择区间右端点；\n2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot；\n3.利用递归实现区间排序。\n双指针法实现区间划分​       左指针从左到右找到第一个不小于基准值的元素，右指针从右到左找到第一个不大于基准值的元素，如果左指针小于右指针，则交换两个指针对应的元素，直到左指针大于等于右指针时停止迭代。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e6 + 10;\nint n;\nint q[N];\nvoid quick_sort(int q[], int l, int r) {\n    if(l &gt;= r) return;\n    int pivot = q[l], i = l - 1, j = r + 1;\n    while(i &lt; j) {\n        // 找到第一个不小于基准值的元素\n        do ++i; while(q[i] &lt; pivot);\n        // 找到第一个不大于基准值的元素\n        do --j; while(q[j] &gt; pivot);\n        if(i &lt; j) swap(q[i], q[j]);\n    }\n    // j指向第一个区间的最后一个元素\n    // Warning: 使用j进行划分时,pivot不能取到区间右端点,算例[1, 2]会陷入死循环\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;q[i]);\n    quick_sort(q, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", q[i]);\n    return 0;\n}\n\n算法优化时间复杂度分析\n最好情况\n每次选取的pivot都能将数组平均划分为两部分，由于划分的过程为，递归深度为，所以总的运行时间为。\n\n最坏情况\n假设始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分只能将问题规模减少１，所以运行时间为。\n\n\n​       排序算法对数据的有序性敏感，其时间复杂度会退化为，典型如LeetCode 912 排序数组，测试集存在5w个2的算例，利用朴素的快排会TLE。\n两种改进方法​\t   快排的优化主要在于对pivot的选取，对于Choose-Left和Choose-Right，常见的改进方法主要有Random和Median-Of-Three。\nRandompivot = rand() % (l - r) + l\n\nMedian-Of-Threevoid swap_arr_elm(int q[], int elm1, int elm2) {\n    swap(q[elm1], q[elm2]);\n}\nint M3(int q[], int l, int r) {\n    //计算数组中间的元素的下标\n    int mid = (r + l) / 2;\n    //使用三数中值法选择枢轴\n    if (q[l] &gt; q[r])\n        swap_arr_elm(q, l, r);\n    if (q[mid] &gt; q[r])\n        swap_arr_elm(q, mid, r);\n    if (q[mid] &gt; q[l])\n        swap_arr_elm(q, mid, l);\n    //此时，arr[mid] &lt;= arr[l] &lt;= arr[r],low的位置上保存这三个位置中间的值\n    return q[l];\n}\n\n​       上述代码已通过LeetCode、洛谷及牛客等OJ平台的算例测试，可放心食用。\n​       另外，STL源码中的sort方法虽然主要基于快速排序，但对于小区间(临界元素个数为16)会改用insert_sort(插入排序)，且在递归层次过深时利用的是heap_sort(堆排序)。\n\n归并排序基本思路1.以中间点  作为分界点；\n2.调用递归函数 merge_sort 对  和  进行排序；\n3.对两个有序区间进行线性归并。\n双指针法实现线性归并​        维护两个指针  和  表示当前考虑到  里的第  个位置和  的第 j 个位置。保证每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后  即为有序的。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nint n;\nint m[N], tmp[N];\nvoid merge_sort(int m[], int l, int r) {\n    if(l &gt;= r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    merge_sort(m, l, mid);\n    merge_sort(m, mid + 1, r);\n    int k = 0, i = l, j = mid + 1;\n    while(i &lt;= mid &amp;&amp; j &lt;= r)\n        tmp[k++] = m[i] &lt;= m[j]? m[i++]: m[j++];\n    while(i &lt;= mid) tmp[k++] = m[i++];\n    while(j &lt;= r) tmp[k++] = m[j++];\n    for(int i = l, j = 0; i &lt;= r; ++i, ++j) m[i] = tmp[j];\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;m[i]);\n    merge_sort(m, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", m[i]);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n","slug":"A1-排序","date":"2022-10-01T09:45:17.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"}]