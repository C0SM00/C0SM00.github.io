[{"id":"6940eb2ba483d3d0018fcb9e180da589","title":"A3-高精度","content":"","slug":"A3-高精度","date":"2022-10-01T09:46:35.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"7092e7a06827631ebc7687e38da9f572","title":"A2-二分","content":"","slug":"A2-二分","date":"2022-10-01T09:46:09.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"95cb927361df204c35cf3acbf99ad432","title":"A1-快速&归并排序","content":"快速排序\n\n\n\n\n\n\n\n\n1.确定pivot(基准值)，一般选择区间右端点；\n2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot；\n3.利用递归实现区间排序。\n利用双指针法实现区间划分​       左指针从左到右找到第一个不小于基准值的元素，右指针从右到左找到第一个不大于基准值的元素，如果左指针小于右指针，则交换两个指针对应的元素，直到左指针大于等于右指针时停止迭代。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N &#x3D; 1e6 + 10;\nint n;\nint q[N];\nvoid quick_sort(int q[], int l, int r) &#123;\n    if(l &gt;&#x3D; r) return;\n    int pivot &#x3D; q[l], i &#x3D; l - 1, j &#x3D; r + 1;\n    while(i &lt; j) &#123;\n        &#x2F;&#x2F; 找到第一个不小于基准值的元素\n        do ++i; while(q[i] &lt; pivot);\n        &#x2F;&#x2F; 找到第一个不大于基准值的元素\n        do --j; while(q[j] &gt; pivot);\n        if(i &lt; j) swap(q[i], q[j]);\n    &#125;\n    &#x2F;&#x2F; j指向第一个区间的最后一个元素\n    &#x2F;&#x2F; warning: 使用j进行划分时,base不能取到区间右端点,算例[1, 2]会陷入死循环\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n&#125;\nint main() &#123;\n    scanf(&quot;%d&quot;, &amp;n);\n    for(int i &#x3D; 0; i &lt; n; ++i) scanf(&quot;%d&quot;, &amp;q[i]);\n    quick_sort(q, 0, n - 1);\n    for(int i &#x3D; 0; i &lt; n; ++i) printf(&quot;%d&quot;, q[i]);\n    return 0;\n&#125;\n\n考虑数据不确定性的算法优化​\t\t首先对快速排序的时间复杂度进行分析：\n\n最好情况\n​       每次选取的pivot都能将数组平均地划分为两部分，由于划分的过程为O(n)，所以总的运行时间为O(nlogn)。      \n\n最坏情况\n​       假设始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分只能将问题规模减少１，所以运行时间为O(n^2)。\n\n\n​       排序算法对数据的有序性敏感，且对于大量重复数据，其时间复杂度也可能会退化为O(n^2)，典型如LeetCode 912 排序数组，存在5w个2的算例，利用朴素的快排会TLE。\n​\t   快排的优化主要在于对pivot的选取，对于Choose-Left和Choose-Right，常见的改进方法有Random和Median-Of-Three：\nRandompivot &#x3D; rand() % (l - r) + l\n\nMedian-Of-Threevoid swap_arr_elm(int q[], int elm1, int elm2) &#123;\n    swap(q[elm1], q[elm2]);\n&#125;\nint M3(int q[], int l, int r) &#123;\n    &#x2F;&#x2F;计算数组中间的元素的下标\n    int mid &#x3D; (r + l) &#x2F; 2;\n    &#x2F;&#x2F;使用三数中值法选择枢轴\n    if (q[l] &gt; q[r])\n        swap_arr_elm(q, l, r);\n    if (q[mid] &gt; q[r])\n        swap_arr_elm(q, mid, r);\n    if (q[mid] &gt; q[l])\n        swap_arr_elm(q, mid, l);\n    &#x2F;&#x2F;此时，arr[mid] &lt;&#x3D; arr[l] &lt;&#x3D; arr[r],low的位置上保存这三个位置中间的值\n    return q[l];\n&#125;\n\n​       上述代码已通过LeetCode、洛谷及牛客等OJ平台的算例测试，可放心食用。\n​       另外，STL源码中的sort方法虽然主要基于快速排序，但对于小区间(临界元素个数为16)会改用插入排序，且在递归层次过深时利用的是堆排序。\n","slug":"A1-排序","date":"2022-10-01T09:45:17.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"}]