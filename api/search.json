[{"id":"53c09180021c67258f4511b4ed283d51","title":"A4-前缀和差分","content":"前缀和一维前缀和// a的下标从1开始 a[1...n], 初始化 s[0] = 0\nint s[N] = {0};\nfor(int i = 1; i &lt;= n; ++i) s[i] = s[i - 1] + a[i];\n// 一维前缀和的主要作用就是求数组 [l, r] 区间内的和 s_lr\ns_lr = s[r] - s[l - 1];\n\n\n\n\n\n\n\nC++的默认初始化机制\n数值型全局变量和静态变量均会默认初始化为0，而函数体(包括main函数)中定义的局部变量未被初始化，它的值是不确定的。\n\n\n求数组  区间内的元素和，朴素的遍历求和法进行m次询问的时间复杂度为 ，而利用前缀和单次询问的时间复杂度为。\n二维前缀和\n// 二维数组 a 从 a[1][1] 开始\n// s[i][j] 代表右下角坐标为 (i, j), 且大小为 i*j 的子矩阵中所有元素的和\nfor(int i = 1; i &lt;= n; ++i) \n    for(int j = 1; j &lt;= m; ++j)\n        s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];\n\n// 计算 以(x1, y1)和(x2, y2)为左上和右下角坐标的子矩阵的元素和 \nans = s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]\n\n\n差分差分和前缀和相当于逆运算。差分的目的是构造差分数列使得原数列是它的前缀和，利用这一性质可以高效地执行对区间内的元素加减同一个数的操作，时间复杂度为。\n一维差分#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 100010;\nint n, m;\n// a 为原数列, b 为 a 的差分数列\nint a[N], b[n];\n// 对数列 a 的 [l, r] 进行 +val 操作, 只需要对差分数列 b 做 O(1) 的操作\nvoid insert(int l, int r, int val) {\n    b[l] += val;\n    b[r + 1] -= val;\n}\nint main() {\n    scanf(\"%d%d\", &amp;n, &amp;m);\n    for(int i = 1; i &lt;= n; ++i) scanf(\"%d\", &amp;a[i]);\n    // 构造差分数列\n    // a = [0,...,0] b = [0,...,0] 给a[i]赋值相当于对 [l, r] 进行 +a[i] 操作\n    for(int i = 1; i &lt;= n; ++i) insert(i, i, a[i]);\n    while(m--) {\n        int l, r, val;\n        scanf(\"%d%d%d\", &amp;l, &amp;r, &amp;val);\n        insert(l, r, val);\n    }\n    // 在差分数列的基础上计算前缀和，即为操作后的数列\n    for(int i = 1; i &lt;= n; ++i) b[i] += b[i - 1];\n    for(int i = 1; i &lt;= n; ++i) printf(\"%d \", b[i]);\n}\n\n二维差分","slug":"A4-前缀和差分","date":"2022-10-05T05:52:23.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"6940eb2ba483d3d0018fcb9e180da589","title":"A3-高精度","content":"高精度\n\n\n\n\n\nTIP\nc++ 中 unsigned long long 的数量级是 ，因此超过该数量级的数值处理就要涉及高精度运算。\n\n\n大数存储为方便处理进位，将大数在数组中逆序存储。\nint main() {\n    string s1, s2;\n    vector&lt;int&gt; num1, num2;\n    // 方便起见，首先利用字符串读取输入数据，再转化为数组\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    // Warning: 数字字符转换为数值时需要减'0'\n    for(int i = s1.size() - 1; i &gt;= 0; --i) num1.push_back(s1[i] - '0');\n    for(int i = s2.size() - 1; i &gt;= 0; --i) num2.push_back(s2[i] - '0');\n}\n\n高精度加法vector&lt;int&gt; add(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n    vector&lt;int&gt; res;\n    // Warning: 注意初始化进位\n    int t = 0;\n    for(int i = 0; i &lt; num1.size() || i &lt; num2.size(); ++i) {\n        if(i &lt; num1.size()) t += num1[i];\n        if(i &lt; num2.size()) t += num2[i];\n        res.push_back(t % 10);\n        t /= 10;\n    }\n    // 判断最高位是否存在进位\n    if(t) res.push_back(t); // ==&gt; res.push_back(1)\n    return res;\n}\n\n高精度减法// 判断 num1 是否 &gt;= num2\nbool cmp(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n\tif(num1.size() != num2.size()) return num1.size() &gt; num2.size();\n    for(int i = num1.size() - 1; i &gt;= 0; --i) \n        if(num1[i] != num2[i])\n            return num1[i] &gt; num2[i];\n    return true;\n}\n// 使用 sub 函数的条件是 num1 &gt;= num2\nvector&lt;int&gt; sub(vector&lt;int&gt; &amp;num1, vector&lt;int&gt; &amp;num2) {\n    vector&lt;int&gt; res;\n    int t = 0;\n    for(int i = 0; i &lt; num1.size(); ++i) {\n        t = num1[i] - t;\n        if(i &lt; num2.size()) t -= num2[i];\n        // (t + 10) % 10 综合了 (t &gt;= 0) -&gt; (t = t) 和 (t &lt; 0) -&gt; (t = t + 10) 两种情况\n        res.push_back((t + 10) % 10);\n        // 处理借位\n        t = t &lt; 0? 1 : 0;\n    }\n    // 删除前导0，但注意结果为0时需要保留最后一个0\n    while(res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();\n\treturn res;\n}\nint main() {\n    /* 大数存储部分略 */\n    if(!cmp(num1, num2)) {\n        res = sub(num2, num1);\n        printf(\"-\");\n    } else {\n        res = sub(num1, num2);\n    }\n    for(int i = res.size() - 1; i &gt;= 0; --i) printf(\"%d\", res[i]);\n}\n\n高精度乘低精度vector&lt;int&gt; mul(vector&lt;int&gt; &amp;num1, int num2) {\n    vector&lt;int&gt; res;\n\tint t = 0;\n    // 循环条件为 num1 的数位未完全遍历 或 t中存在进位\n    for(int i = 0; i &lt; num1.size() || t; ++i) {\n        if(i &lt; num1.size()) t += num1[i] * num2;\n        res.push_back(t % 10);\n        t /= 10;\n    }\n    return res;\n}\n\n高精度除低精度vector&lt;int&gt; div(vector&lt;int&gt; &amp;num1, int num2, int &amp;r) {\n    vector&lt;int&gt; res;\n    int r = 0;\n    for(int i = num1.size() - 1; i &gt;= 0; --i) {\n\t\tr = r * 10 + num1[i]; // 关键\n        res.push_back(r / num2);\n        r %= num2;\n    }\n    reverse(res.begin(), res.end());\n    while(res.size() &gt; 1 &amp;&amp; res.back() == 0) res.pop_back();\n    return res;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"A3-高精度","date":"2022-10-01T09:46:35.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"7092e7a06827631ebc7687e38da9f572","title":"A2-二分","content":"整数二分\n\n\n\n\n\n二分问题的本质\n基于某个预设条件，可将区间划分为两个连续的状态区间(满足/不满足)，问题的答案就在区间的边界上。\n\n\n两种二分模板// 模板1：区间[l, r]被划分为[l, mid]和[mid + 1, r]\nint bin_search_1(int l, int r) {\n    while(l &lt; r) {\n        int mid = l + r &gt;&gt; 1;\n        if(check(mid)) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\n\n// 模板2：区间[l, r]被划分成[l, mid - 1]和[mid, r]\nint bin_search_2(int l, int r) {\n    while(l &lt; r) {\n        // Warning:此处mid应取右，否则当l=r-1时左边界取左会陷入死循环\n\t\tint mid = l + r + 1 &gt;&gt; 1;\n        if(check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n\n模板的选择\n边界  和  怎么更新，取决于目标答案是 ans1 还是 ans2，当 mid 落在右区间时，mid 可能就是 ans2 ，那么在寻找 ans2 时右边界  应更新为 mid，反之在寻找 ans1 时右边界应更新为 mid - 1。确定题目的目标是 ans1 还是ans2 只需要判断答案是否满足预设条件。\n\n\n\n\n\n\n解题关键\n-确定区间的划分条件\n-确定区间边界的更新方式\n-根据更新方式确定mid的计算方式(取左还是取右)\n\n\n\n浮点数二分浮点数二分不需要考虑边界条件，只需要设定答案精度作为迭代停止的条件。\n","slug":"A2-二分","date":"2022-10-01T09:46:09.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"},{"id":"95cb927361df204c35cf3acbf99ad432","title":"A1-快速&归并排序","content":"快速排序基本思路1.确定pivot(基准值)，一般选择区间右端点；\n2.将所有元素按pivot划分为两个子区间，其中左区间元素小于等于pivot，右区间元素大于等于pivot；\n3.利用递归实现区间排序。\n双指针法实现区间划分左指针从左到右找到第一个不小于基准值的元素，右指针从右到左找到第一个不大于基准值的元素，如果左指针小于右指针，则交换两个指针对应的元素，直到左指针大于等于右指针时停止迭代。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e6 + 10;\nint n;\nint q[N];\nvoid quick_sort(int q[], int l, int r) {\n    if(l &gt;= r) return;\n    int pivot = q[l], i = l - 1, j = r + 1;\n    while(i &lt; j) {\n        // 找到第一个不小于基准值的元素\n        do ++i; while(q[i] &lt; pivot);\n        // 找到第一个不大于基准值的元素\n        do --j; while(q[j] &gt; pivot);\n        if(i &lt; j) swap(q[i], q[j]);\n    }\n    // j指向第一个区间的最后一个元素\n    // Warning: 使用j进行划分时,pivot不能取到区间右端点,算例[1, 2]会陷入死循环\n    quick_sort(q, l, j);\n    quick_sort(q, j + 1, r);\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;q[i]);\n    quick_sort(q, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", q[i]);\n    return 0;\n}\n\n算法优化时间复杂度分析\n最好情况\n每次选取的pivot都能将数组平均划分为两部分，由于划分的过程为，递归深度为，所以总的运行时间为。\n\n最坏情况\n假设始终选取第一个元素作为pivot, 并且输入数组是有序的，那么每次划分只能将问题规模减少１，所以运行时间为。\n\n\n排序算法对数据的有序性敏感，其时间复杂度会退化为，典型如LeetCode 912 排序数组，测试集存在5w个2的算例，利用朴素的快排会TLE。\n两种改进方法快排的优化主要在于对pivot的选取，对于Choose-Left和Choose-Right，常见的改进方法主要有Random和Median-Of-Three。\nRandompivot = rand() % (l - r) + l\n\nMedian-Of-Threevoid swap_arr_elm(int q[], int elm1, int elm2) {\n    swap(q[elm1], q[elm2]);\n}\nint M3(int q[], int l, int r) {\n    //计算数组中间的元素的下标\n    int mid = (r + l) / 2;\n    //使用三数中值法选择枢轴\n    if (q[l] &gt; q[r])\n        swap_arr_elm(q, l, r);\n    if (q[mid] &gt; q[r])\n        swap_arr_elm(q, mid, r);\n    if (q[mid] &gt; q[l])\n        swap_arr_elm(q, mid, l);\n    //此时，arr[mid] &lt;= arr[l] &lt;= arr[r],low的位置上保存这三个位置中间的值\n    return q[l];\n}\n\n上述代码已通过LeetCode、洛谷及牛客等OJ平台的算例测试，可放心食用。\n另外，STL源码中的sort方法虽然主要基于快速排序，但对于小区间(临界元素个数为16)会改用insert_sort(插入排序)，且在递归层次过深时利用的是heap_sort(堆排序)。\n\n归并排序基本思路1.以中间点  作为分界点；\n2.调用递归函数 merge_sort 对  和  进行排序；\n3.对两个有序区间进行线性归并。\n双指针法实现线性归并维护两个指针  和  表示当前考虑到  里的第  个位置和  的第 j 个位置。保证每次都是让两个区间中较小的数加入临时数组里，那么整个归并过程结束后  即为有序的。\n#include&lt;iostream&gt;\nusing namespace std;\nconst int N = 1e5 + 10;\nint n;\nint m[N], tmp[N];\nvoid merge_sort(int m[], int l, int r) {\n    if(l &gt;= r) return;\n    int mid = (l + r) &gt;&gt; 1;\n    merge_sort(m, l, mid);\n    merge_sort(m, mid + 1, r);\n    // 递归调用后，两个区间均有序\n    int k = 0, i = l, j = mid + 1;\n    // 利用双指针法每次将较小的数加入tmp数组\n    while(i &lt;= mid &amp;&amp; j &lt;= r)\n        tmp[k++] = m[i] &lt;= m[j]? m[i++]: m[j++];\n    // 如果有一个指针已经移到了区间的末尾，那么就把另一个区间里的数按顺序加入tmp数组中即可\n    while(i &lt;= mid) tmp[k++] = m[i++];\n    while(j &lt;= r) tmp[k++] = m[j++];\n    // 用有序的tmp数组替换原数组的[l, r]区间\n    for(int i = l, j = 0; i &lt;= r; ++i, ++j) m[i] = tmp[j];\n}\nint main() {\n    scanf(\"%d\", &amp;n);\n    for(int i = 0; i &lt; n; ++i) scanf(\"%d\", &amp;m[i]);\n    merge_sort(m, 0, n - 1);\n    for(int i = 0; i &lt; n; ++i) printf(\"%d\", m[i]);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n","slug":"A1-排序","date":"2022-10-01T09:45:17.000Z","categories_index":"算法","tags_index":"AcWing算法基础课","author_index":"MiF"}]